# Overview

## why rust

+ Fast (naive code, no garbage collector, most abstractions has zero cost, fine-grained control over lots of things)
+ Safe (no null, no uninitialized memory, no dangling pointers, no double free errors, no manual memory management)
+ Functional (First-class functions, Trait-based generics, Algebraic datatypes, Pattern matching)

### Tools

#### Rustc

#### Cargo

+ `cargo new project_name`
+ `cargo new project_name --bin`
+ `cargo build`
+ `cargo test`

##### `Cargo.toml`

```yml
[package]
name = "rust"
version = "0.1.0"
authors = ["ddd@xxx.com"]

[dependencies]
uuid = "0.1"
rand = "0.3"

[profile.release]
opt-level = 3
debug = false

```

### Basic rust syntax

#### Variable Bindings

```rust
let x = 17;
let x: i16 = 17;
let mut y = 5;
y += 1;
let (a, b) = ("foo", 12);
```

#### Expressions

+ Everything is an expression: something which returns a value.
+ `nothing` type is called `unit`, which is written `()`
+ A expression appending a semicolon return `()`.

```rust
let y = if x > 0 { "greeter" } else { "less" }
```

#### Comments

 ```rust
 /// docstring comments
 /// 
 /// `rustdoc` use docstring comments to generate documentatiion, support **Markdown** formatting.
 ///
 fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
 ```

#### Types

##### Primitive Types

+ bool
+ char 'c' '狗' is Unicodel
+ Numerics:
  + i8, i16, i32, i64, isize
  + u8, u16, u32, u64, usize
  + f32, f64
  + isize and usize are the size of pointers, have machine dependencies
  + Literial splled 10i8, 10u16 10.0f32, 10usize
+ Arrays, slices, str, tuples
  + Array: [T; N] cannot be resize, access will be bounds-checked at runtime
  + Slices: &[T] a "view" into an array by reference, created directly, borrowed from other variables
  + Strings: String, &str
  + Tuples: fixed size, ordered, heterogeneous list, let bindings desctructure
+ `Vec<T>`

```rust
let init_arr = [2; 32];
let arr = [1, 2, 3, 4, 5];
let total_slice = &arr;
let total_slice = &arr[..];
let partial_slice = &arr[2..5];

let s: &str = "hello";
let s2: String = "hello".to_string();
let s3: String = String::from("hello");
let s4: &str = &s3

let x: i32 = 100;
let y: u32 = x as u32;
```

#### Functions

```rust
fn square_bad(n: i32) -> i32 {
    n * n
}

let x: fn(i32) -> i32 = square_bad;
fn apply_twice(f: &Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

apply_twice(&square_bad, 3);
```

#### Marcros!

+ `print!`, `println!`
+ `format!`
+ `panic!`
+ `assert!`, `assert_eq!`
+ `unreachable!`
+ `unimplemented!`

#### Match Statements

+ `...` specify a range of values
+ `_` bind against any value
+ `if-let`
+ `while-let`
+ inner bindings

```rust
let x = 3;
let y = -3;

match (x, y) {
    (1, 1) => println!("one"),
    (2, j) => println!("two, {}", j),
    (_, 3) => println!("three"),
    (i, j) if i > 5 && j < 0 => println!("On guard!"),
    (_, _) => println!(":<"),
}

let x = 17;

match x {
    0 ... 5 => println!("zero through five (inclusive)"),
    _ => println!("You still lose the game."),
}

let result = make_request();

if let Resultish::Err(s) = result {
    println!("Total and utter failure: {}", s);
} else {
    println!("ok.");
}

while let Resultish::Err(s) = make_request() {
    println!("Total and utter failure: {}", s);
}

#[derive(Debug)]
enum A { None, Some(B) }
#[derive(Debug)]
enum B { None, Some(i32) }

fn foo(x: A) {
    match x {
        a @ A::None              => println!("a is A::{:?}", a),
        ref a @ A::Some(B::None) => println!("a is A::{:?}", *a),
        A::Some(b @ B::Some(_))  => println!("b is B::{:?}", b),
    }
}

foo(A::None);             // ==> x is A::None
foo(A::Some(B::None));    // ==> a is A::Some(None)
foo(A::Some(B::Some(5))); // ==> b is B::Some(5)
```

## Ownership, Borrowing, Lifetimes

> 以后再总结

+ Ownership checked at compile time, no running time costs
+ A piece of data can only hava one owner at a time
+ when bingding goes out of scope,bound data is released automatically
+ move semantics
+ Multiple Lifetime Parameters
+ `'static` a reference may be kept for the lifetime of the entire program, never go out of scope, `'str` is `'static`

```rust
struct Pizza(Vec<i32>);
struct PizzaSlice<'a> { pizza: &'a Pizza, index: u32 }
struct PizzaConsumer<'a, 'b: 'a> { // says "b outlives a"
    slice: PizzaSlice<'a>, // <- currently eating this one
    pizza: &'b Pizza,      // <- so we can get more pizza
}

fn get_another_slice(c: &mut PizzaConsumer, index: u32) {
    c.slice = PizzaSlice { pizza: c.pizza, index: index };
}

let p = Pizza(vec![1, 2, 3, 4]);
{
    let s = PizzaSlice { pizza: &p, index: 1 };
    let mut c = PizzaConsumer { slice: s, pizza: &p };
    get_another_slice(&mut c, 2);
}
```

1. 定义在 struct、返回值、enum、Type 中的引用类型必须规定好 Lifetime 参数。函数中有 lifetime elision 但有可能不够。
1. 维持一个内存对象的指针和引用是危险的，主要来自于以下两个方面：
  + 指针指向的一个已经离开可见范围的对象。
  + 指针指向一个已经修改到别处的对象。

可以将 Lifetime 认为是程序中一个可见范围的名称，当一个 reference 存在一个 lifetime 时，我们认为他在这整个范围内是合法的。
不同情况下，reference 有不同的必须或可以合法的范围。整个 lifetime 系统从另一方面讲，知识一种限定解决系统，管理每个 refenece 的可见范围。当发现 lifetime 的集合满足所有的限制时，你的程序便可以编译，否则，你会快速给你错误信息。

在函数内部，编译器可以获得足够的信息来处理所有的 lifetime，但是对于整个 type 和 API 层，编译器则无法获得全部的信息，需要你来告诉他一些信息。

指针错误是全局的，难以发现和处理。rust 使用 lifetime，使得我们可以在函数内部发现和处理这些问题。rust 可以保证，没有对象会在 free 后还被使用，以及还有外部指针指向它时，被修改。

## Data Struct

### Struct

+ struct may not be partially-initialized
+ do not have field-level mutability
+ stucts fields are private by default - can only be accessed from within module where the struct is declared
+ tuple structs

```rust
pub struct Point {
    x: i32,
    y: i32,
}

match p {
    Point { x, y } => println!("({}, {})", x, y)
}

match p {
    Point { y, .. } => println!("{}", y)
}

struct Foo { a: i32, b: i32, c: i32, d: i32, e: i32 }

let mut x = Foo { a: 1, b: 1, c: 2, d: 2, e: 3 };
let x2 = Foo { e: 4, .. x };

// Useful to update multiple fields of the same struct:
x = Foo { a: 2, b: 2, e: 2, .. x };

struct Color(i32, i32, i32);

let mut c = Color(0, 255, 255);
c.0 = 255;
match c {
    Color(r, g, b) => println!("({}, {}, {})", r, g, b)
}
// Not equatable
struct Meters(i32);
struct Yards(i32);

// May be compared using `==`, added with `+`, etc.
type MetersAlias = i32;
type YardsAlias  = i32;

struct Unit;
let u = Unit;
```

### Enums

+ No data
+ Named data
+ Unnamed ordered data

```rust
enum Resultish {
    Ok,
    Warning { code: i32, message: String },
    Err(String)
}

match make_request() {
    Resultish::Ok =>
        println!("Success!"),
    Resultish::Warning { code, message } =>
        println!("Warning: {}!", message),
    Resultish::Err(s) =>
        println!("Failed with error: {}", s),
}
```

### Method

+ `&self`, `&mut self`, `self`

```rust
impl Point {
    fn distance(&self, other: Point) -> f32 {
        let (dx, dy) = (self.x - other.x, self.y - other.y);
        ((dx.pow(2) + dy.pow(2)) as f32).sqrt()
    }

    fn translate(&mut self, x: i32, y: i32) {
        self.x += x;
        self.y += y;
    }

    fn mirror_y(self) -> Point {
        Point { x: -self.x, y: self.y }
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.distance();
}

```

### Associated Functions

```rust
impl Point {
    fn new(x: i32, y: i32) -> Point {
        Point { x: x, y: y }
    }
}

fn main() {
    let p = Point::new(1, 2);
}
```

### Recursive Types

#### Boxes

+ box: a general term for one of Rust's ways of allocating data on the heap
+ `Box<T>` is a heap pointer with exactly one owner
+ when go out of scope, Box will automatically destructed

```rust
let boxed_five = Box::new(5);

enum List {
    Nil,
    Cons(i32, Box(List)),
}
```

## Generics

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

struct Point<T> {
    x: T,
    y: T,
}

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>),
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        match *self {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

```

### Generic Functions

```rust
fn foo<T, U>(x: T, y: U) {
    // ...
}
```

### Generics with Triat Bounds

```rust
fn cloning_machine<T: Clone>(t: T) -> (T, T) {
    (t.clone(), t.clone())
}

fn cloning_machine_2<T>(t: T) -> (T, T)
        where T: Clone {
    (t.clone(), t.clone())
}

fn clone_and_compare<T: Clone + Ord>(t1: T, t2: T) -> bool {
   t1.clone() > t2.clone()
}

enum Result<T, E> {
   Ok(T),
   Err(E),
}

trait PrettyPrint {
   fn format(&self) -> String;
}

impl<T: PrettyPrint, E: PrettyPrint> PrettyPrint for Result<T, E> {
   fn format(&self) -> String {
      match *self {
         Ok(t) => format!("Ok({})", t.format()),
         Err(e) => format!("Err({})", e.format()),
      }
   }
}
```

## Traits

```rust

trait PrettyPrint {
    fn format(&self) -> String;
}

struct Point {
    x: i32,
    y: i32,
}

impl PrettyPrint for Point {
    fn format(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}
```

### Trait Inheritance

+ `Eq` requires `PartialEq`, `Copy` requires `Clone`
+ Implementing the `Child` trait also requires you implement `Parent`

```rust
trait Parent {
    fn foo(&self) {
        // ...
    }
}

trait Child: Parent {
    fn bar(&self) {
        self.foo();
        // ...
    }
}
```

### Default Methods

+ trait can have default implementations for methods

```rust
trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)
    }
}

trait Eq: PartialEq<Self> {}
```

### Deriving

+ A `#[derive(...)]` attribute tells the compiler to insert a default implementation for whatever traits you tell it to

```rust
#[derive(Eq, PartialEq, Debug)]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

#### Clone

+ how to duplicate a value of type T
+ can solve ownership problems

```rust
pub trait Clone: Sized {
    fn clone(&self) -> Self;
    fn clone_from(&mut self, source: &Self) { ... }
}

// use:

#[derive(Clone)] // without this, Bar cannot derive Clone.
struct Foo {
    x: i32,
}

#[derive(Clone)]
struct Bar {
    x: Foo,
}
```

#### Copy

+ Copy denotes that a type has "copy semantics" instead of "move semantics."
+ Type must be able to copied by copying bits, Types that contain references cannot be copy

```rust
pub trait Copy: Clone { }
```

#### Debug

+ defines output for the `{:?}` formatting option

```rust
pub trait Debug {
    fn fmt(&self, &mut Formatter) -> Result;
}
```

#### Default

```rust
pub trait Default: Sized {
    fn default() -> Self;
}
```

#### Eq vs. PartialEq

```rust
pub trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool { ... }
}

pub trait Eq: PartialEq<Self> {}
```

| name | condition |
|:--- |:--- |
| PartialEq | Symmetric, Transitive |
| Eq | Symmetric, Transitive, Reflexive |

+ Symmetrics: `a == b` => `b == a`
+ Transitive: `a == b` and `b == c` => `a == c`
+ Reflexive:  `a == a`

#### Hash

```rust
pub trait Hash {
    fn hash<H: Hasher>(&self, state: &mut H);
    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)
        where Self: Sized { ... }
}
```

+ a hashable type
+ H type parameter is an abstract hash state for computing the hash
+ `Eq` and `Hash` trait should have constraint: `k1 == k2` => `hash(k1) == hash(k2)`

#### Ord vs. PartialOrd

```rust
pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {
    // Ordering is one of Less, Equal, Greater
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd<Self> {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

#### Associated Types

##### Primative solution

+ `N` and `E` don't have any meaningful association to graph
+ method `distance`  shoudl also be generic over `N` and `E`

```rust
trait Graph<N, E> {
    fn edges(&self, &N) -> Vec<E>;
    // etc
}

fn distance<N, E, G: Graph<N,E>>(graph: &G, start: &N, end: &N)
    -> u32 { /*...*/ }
```

##### Associated Types solution

```rust
trait Graph {
  type N;
  type E;

  fn edges(&self, &Self::N) -> Vec<Self::E>;
}

impl Graph for MyGraph {
  type N = MyNode;
  type E = MyEdge;

  fn edges(&self, n: &MyNode) -> Vec<MyEdge> { /*...*/ }
}
```

#### Trait Scope

+ It's possible to implement this trait on any type in rust, including types that you don't own.
+ You need to use a trait in order to access its methods on types, even if you have access to the type.
+ In order to write an impl, you need to own (i.e. have yourself defined) either the trait or the type.

#### Display

+ defind output for {} formatting option

```rust
pub trait Display {
    fn fmt(&self, &mut Formatter) -> Result<(), Error>;
}

impl Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point {}, {})", self.x, self.y)
    }
}
```

#### Addendum: Drop

+ a trait for destructable
+ never call this method yourself
+ 

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

## Closure

### Basic Syntax

```rust
let foo_v1 = |x: i32| { x * x };
let foo_v2 = |x: i32, y: i32| x * y;
let foo_v3 = |x: i32| {
    // Very Important Arithmetic
    let y = x * 2;
    let z = 4 + y;
    x + y + z
};
let foo_v4 = |x: i32| if x == 0 { 0 } else { 1 };
```

### Closure Environment

> 待总结

### Closure Traits

```rust
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call"
      fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call"
      fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    type Output;

    extern "rust-call"
      fn call_once(self, args: Args) -> Self::Output;
}
```

### Closure as Arguments

```rust
// self = Vec<A>
fn map<A, B, F>(self, f: F) -> Vec<B>
    where F: FnMut(A) -> B;
```

### Closure as Return values

+ the trait `std::marker::Sized` is not implemented for `std::ops::Fn(i32) -> i32 + 'static`
+ return type `&` must explicit lifetime
+ return struct with no `Sized` trait must `Box`ed

```rust
// error!
fn i_need_some_closure() -> (Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// reviewed but error
fn i_need_some_closure_by_reference() -> &(Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// final
fn box_up_your_closure_and_move_out() -> Box<Fn(i32) -> i32> {
    let local = 2;
    Box::new(move |x| x * local)
}
```

## Std Lib

### String

+ A String and an &str may be concatenated with +, Concatenating two Strings requires coercing one to &str.

concersion case:

```rust
use std::net::TcpStream;

TcpStream::connect("192.168.0.1:3000"); // &str
let addr = "192.168.0.1:3000".to_string();
TcpStream::connect(&*addr);
```
This doesn't automatically coerce because TcpStream doesn't take an argument of type &str, but a Trait bounded type:
`TcpStream::connect<A: ToSocketAddr>(addr: A)`

```rust
trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

+ Since String implements `Deref<Target=str>`, so values of &String will automatically be dereferenced to &str when possible.
+ `Vec`、`&str` 可以方便的转换为 String
+  Copy a `String` is expensive;

### `Option<T>`

```rust
enum Option<T> {
    None,
    Some(T),
}

fn unwrap<T>(&self) -> T;
fn map<U, F>(self, f: F) -> Option<U> { ... };
fn and_then<U, F>(self, f: F) -> Option<U>
      where F: FnOnce(T) -> Option<U> { ... };
fn unwrap_or<T>(&self, default: T) -> T { ... };
fn unwrap_or_else<T>(&self, f: F) -> T
            where F: FnOnce() -> T { ... };

fn is_some(&self) -> bool { ... };
fn is_none(&self) -> bool { ... };
fn map_or<U, F>(self, default: U, f: F) -> U
    where F: FnOnce(T) -> U { ... };
fn map_or_else<U, D, F>(self, default: D, f: F) -> U
    where D: FnOnce() -> U, F: FnOnce(T) -> U { ... };
fn ok_or(self, err: E) -> Result<T, E> { ... };
fn ok_or_else(self, default: F) -> Result<T, E>
    where F: FnOnce() -> E { ... };
fn and<U>(self, optb: Option<U>) -> Option<U> { ... };
fn or(self, optb: Option<T>) -> Option<T> { ... };
```

### `Result<T, E>`

```rust
enum Result<T, E> {
    Ok(T),
    Err(E)
}
```

+ Unlike Option, you should always consume `Result`, such as `unwrap` or `expect` or handle `Ok` / `Err`。

### Collections

+ `Vec<T>`
+ `VecDeque<T>`
+ `LinkedList<T>`
+ `HashMap<K, V>`
    - `K: Hash + Eq`
+ `BTreeMap<K, V>`
    - `K: Ord`
+ `BinaryHeap<T>`

#### `Iterator`

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;

    // More fields omitted
}
```

+ three types of iteration:
  + `into_iter()` yield `T`
  + `iter()` yielding `&T`
  + `iter_mut()` yielding `&mut T`

##### `collect`

```rust
fn collect<B>(self) -> B where B: FromIterator<Self::Item>
```

+ `collect()` rolls a lazy iterator back into an actual collection。
+ target collection must define the `FromIterator` trait for the `Item` inside the Iterator.
+ Sometimes needs a type hint to properly compile.

##### `fold`

```rust
fn fold<B, F>(self, init: B, f: F) -> B
    where F: FnMut(B, Self::Item) -> B;
```

##### `filter`

```rust
fn filter<P>(self, predicate: P) -> Filter<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```

+ `filter` returns a `Filter<Self, P>`

##### `find` and `position`

```rust
fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
    where P: FnMut(Self::Item) -> bool;

fn position<P>(&mut self, predicate: P) -> Option<usize>
    where P: FnMut(Self::Item) -> bool;
```

##### `skip`

```rust
fn skip(self, n: usize) -> Skip<Self>;
```

##### `zip`

```rust
fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>
    where U: IntoIterator;
```

##### `any` and `all`

```rust
fn any<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;

fn all<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;
```

##### `enumerate`

+ use enumerate!
+ (index, value)

```rust
fn enumerate(self) -> Enumerate<Self>;
```

##### Iterator Adapters

+ Adapters operate on an iterator and return a new iterator
+ offen lazy
+ use iterator consumer on an adapter or use it in a for loop

##### `map`

```rust
fn map<B, F>(self, f: F) -> Map<Self, F>
    where F: FnMut(Self::Item) -> B;
```

##### `take` and `take_while`

```rust
fn take(self, n: usize) -> Take<Self>;

fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```

##### `cloned`

```rust
fn cloned<'a, T>(self) -> Cloned<Self>
    where T: 'a + Clone, Self: Iterator<Item=&'a T>;
```

+ Create an iteratir which calls clone on all of its elements.
+ equal to `vs.iter().map(|v| v.clone())`
+ Using: when you have an iterator over `&T`, but need one over `T`

## Pointer Types

+ `&T` and `&mut T`
+ `Box<T>`
+ `std:rc::Rc<T>` `Rc::downgrade()`
+ `std::rc::Weak<T>` `weak.upgrade() -> Option<Rc<T>>`
+ `Cell<T>` 
  + Just providing interior mutability of `Copy` types.
  + With `get()` and `set()` never mutate `T`, just replace it.    
+ `RefCell<T>` 
  + Dynamic borrow checking rules, maybe panic at runtime.
  + `borrow()` and `borrow_mut()`
  + not thread safe, maybe panic at runtime.
  + A common paradigm is putting a `RefCell` inside an `Rc` allow shared mutability
+ `std::cell::Ref<T>` and `RefMut<T>`
  + when you invoke `borrow()` on a `RefCell<T>` actually get `Ref<T>` not `&T`
  + while `borrow_mut()` gives you a `RefMut<T>`
+ `*const T` and `*mut T`
  + no ownership, no lifetime, C-like raw pointers
  + require `unsafe` before dereference

```rust
let c = Cell::new(10);
c.set(2);
println!("{}", c.get());
```

## Misc Syntax

+ `const` must annotate type, and is `live` for the duration of the program, may hava multi references.
+ `static` must annotate type, with fixed memory address, unsafe to mutate, with `static` lifetime.

```rust
const PI: f32 = 3.14159;
static PI: f32 = 3.14159;
```

## Modules and Crates

+ Everything in rust is module-scoped: if it's not pub, it's only accessible from within the same module.

### 1. Modules can be defined within one file

```rust
mod english {
    pub mod greetings {
    }
    pub mod farewells {
    }
}

mod japanese {
    pub mod greetings {
    }
    pub mod farewells {
    }
}
```

### 2. Modules can be defined as files instead

+ `lib.rs`

```rust
mod english;
```

+ `english.rs`

```rust
pub mod greetings { /* .... */ }
```

### 3. Modules can be defined as directories

+ `lib.rs`

```rust
mod english;
```

+ `english/`
  + `mod.rs`
      ```rust
      pub mod greetings;
      ```
  + `greetings.rs`
      ```rust
      /* .... */
      ```

### 4 Namespacing

```rust
mod one {
    mod two {
        fn foo() { ... }
    }
    fn bar() {
        two::foo();
    }
}

mod three {
    mod four {
        pub fn foo() { ... }
    }

    fn bar() {
        ::one::two::foo();
    }
}
```

### 5 `use` in Modules

+ `use` directives are absolute by default
+ can be relative to the current module
+ `pub use` can be used to re-export other items

```rust
use english::greetings;
use self::greetings;
use super::japanese;

#[cfg(english)]
pub use english::*;

#[cfg(japanese)]
pub use japanese::*;
```

## Crate

```rust
extern crate rand;

use rand::Rng;
```

```yaml
[dependencies]
myfoo = { git = "https://github.com/me/foo-rs" }
mybar = { path = "../rust-bar" }

// or
[dependencies]
git = "https://github.com/me/foo-rs"
```

## Cargo

+ cargo allows both: `/src/lib.rs/` and `/src/main.rs`
+ cargo will also build: `/src/bin/*.rs` as executables.
+ Examples in `/examples/*.rs` will build by `cargo test`, can be called with `cargo run --example foo`
+ integrate tests in: `/tests/*.rs`
+ benchmarks in `/benches/*.rs`

### Features

+ build time use: `cargo build --features using-html9`

```yaml
[package]
name = "myfacebumblr"

[features]
# Enable default dependencies: require web-vortal *feature*
default = ["web-vortal"]

# Extra feature; now we can use #[cfg(feature = "web-vortal")]
web-vortal = []

# Also require h9rbs-js *crate* with its commodore64 feature.
using-html9 = ["h9rbs-js/commodore64"]

[dependencies]
# Optional dependency can be enabled by either:
# (a) feature dependencies or (b) extern crate h9rbs_js.
h9rbs-js = { optional = "true" }
```

### build scripts

script write by rust can provide more cargo can do.

```rust
[package]
build = "build.rs"
```

### Attributes

+ `#[test]`
+ `#![test]`
+ `#![no_std]`
+ `#[inline(always)]`
+ `#[allow(missing_docs)]`
+ `#![crate_type = "lib"]`
+ `#![feature(box_syntax)]`
+ `#[cfg(target_os = "linux")]`

## [Rust Code Stype](https://github.com/cis198-2016s/slides/blob/gh-pages/07/content.md#rust-code-style-1)

+ `CamelCase`:              types, traits.
+ `lowerCamelCase`:         not used.
+ `snake_case`:             crates, modules, functions, methods, variables.
+ `SCREAMING_SNAKE_CASE`:   static variables and constants.
+ `T`                       (single capital letter): type parameters.
+ `'a`                      (tick + short lowercase name): lifetime parameters.

+ Constructor and conversions should be worded:
  + `new`, `new_with_stuff`: constructors.
  + `from_foo`: conversion constructors.
  + `as_foo`: free non-consuming conversion.
  + `to_foo`: expensive non-consuming conversion.
  + `into_foo`: consuming conversion.

## `format!`

+ `{<num>:<triat>}`
  + `<num>` the index of the argument list
  + `<trait>` use of trait

| spec | trait |
|:---  |:--- |
| `{}` | Display |
| `{:x}` | LowerHex |
| `{:b}` | Binary |
| `{:?}` | Debug |
| `{:X}` | UpperHex |
| `{:e}` | LowerExp |
| `{:o}` | Octal |
| `{:p}` | Pointer |
| `{:E}` | UpperExp |

+ `{:04}` -> `0010`: padding
+ `'{:^4}'` -> `' 10 '`: alignment (centering)
+ `#` indicates an "alternate" print format:
+ `{:#X}` -> `0xA`: including 0x
+ `{:#?}`: Pretty-prints objects

## Operators

+ Unary operators: `!` `-` `*` `&` `&mut`
+ `as` casting
+ `*` `/` `%` multiplicative arithmetic
+ `+` `-` additive arithmetic
+ `<<` `>>` shift arithmetic
+ `&` bitwise and
+ `^` bitwise xor
+ `|` bitwise or
+ `==` `!=` `<` `>` `<=` `>=` logical comparison
+ `&&` logical and
+ `||` logical or
+ `=` `..` assignment and ranges

### trait for Operators:

+ Rust defines these - surprise! - using traits, in `std::ops`.
  + `Neg`, `Not`, `Deref`, `DerefMut`
  + `Mul`, `Div`, `Mod`
  + `Add`, `Sub`
  + `Shl`, `Shr`
  + `BitAnd`
  + `BitXor`
  + `BitOr`
  + `Eq`, `PartialEq`, `Ord`, `PartialOrd`
  + `And`
  + `Or`
+ Also: `Fn`, `FnMut`, `FnOnce`, `Index`, `IndexMut`, `Drop`

+ Casting (as) cannot be overloaded. we use `From` an `Into`
  + `trait From<T> { fn from(T) -> Self; }`  called: `Y::from(x)`
  + `trait Into<T> { fn into(self) -> T; }`  called: `x.into()`

```rust
struct A(Vec<i32>);

impl From<Vec<i32>> for A {
    fn from(v: Vec<i32>) -> Self {
        A(v)
    }
}

/// `From` is impossible， so only `Into` is allowed.
impl From<A> for Vec<i32> { // error: private type A in
    fn from(a: A) -> Self { // exported type signature.
        let A(v) = a; v     // (This impl is exported because
    }                       // both the trait (From) and the type
}                           // (Vec) are visible from outside.)

impl Into<Vec<i32>> for A {
    fn into(self) -> Vec<i32> {
        let A(v) = self; v
    }
}
```

### Making Reference

+ `Borrow` / `BorrowMut`: a trait for borrowing data [doc](https://doc.rust-lang.org/std/borrow/trait.Borrow.html)

```rust
trait Borrow<Borrowed> { fn borrow(&self) -> Borrowed; }
```

+ `AsRef` / `AsMut` a cheap, reference-to-reference conversion [doc](https://doc.rust-lang.org/std/convert/trait.AsRef.html)

```rust
trait AsRef<T> { fn as_ref(&self) => &T; }
```

+ If you are implementing Borrow and both Self and Borrowed implement Hash, Eq, and/or Ord, they must produce the same result.
+ Borrow has a blanket implementation: `impl<T> Borrow<T> for T`: you can always convert `T` to `&T`.
+ AsRef actually has its own blanket implementation:
  + `impl<'a, T, U> AsRef<U> for &'a T where T: AsRef<U>`
  + For all `T`, if `T` implements `AsRef`, `&T` also implements `AsRef`

## I/O

### Trait

```rust
pub trait Read {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
    // other methods implemented in terms of read
}

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    // other methods implemented in terms of write() and flash()
}
```

+ Standard IO traits implemented for a variety of types:
  + `File`, `TcpStream`, `Vec<T>`, `&[u8]`
+ return `std::io::Result` not the `std::Result`
  + `type Result<T> = Result<T, std::io::Error>`

### `std::io::Read`

```rust
use std::io;
use std::io::prelude;
use std::fs::File;

let mut f = try!(File::open("foo.txt"));
let mut buffer = [0; 10];

// read up to 10 bytes
try!(f.read(&mut buffer));
```

+ `buffer` is an array, so the max length to read is encoded into the type
+ `read` returns the number of bytes `Ok(n)` read or an Err

```rust
fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
// read to the end of the Read object
fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize>;
// reads to the end of the Read object to a string
fn read_to_string(&mut self, buf: &mut String) -> Result<usize>;
// reads exactly the length of the buffer, or throws an error
fn read_exact(&mut self, buf: &mut [u8]) -> Result<()>;
```

### Reading Iterators

```rust
fn bytes(self) -> Bytes<Self> where Self:Sized;
fn chars(self) -> Bytes<Self> where Self:Sized;
```
+ associated `Item` is `Result<u8>`
    - `next()` return `Option<Result<u8>>`
    - `EOF` corresponds to `None`
+ **Adaptors**

```rust
fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized;

fn take<R: Read>(self, limit: u64) -> Take<Self> where Self: Sized;
```

### `std::io::write`

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    /// Attempts to write entire buffer into self.
    fn write_all(&mut self, buf: &[u8]) -> Result<()> { ... }

    /// Writes a formatted string into self.
    /// Don't call this directly, use `write!` instead.
    fn write_fmt(&mut self, fmt: Arguments) -> Result<()> { ... }

    /// Borrows self by mutable reference.
    fn by_ref(&mut self) -> &mut Self where Self: Sized { ... }
}

// example
let mut buffer = trr!(File::create("foo.txt"));
try!(buffer.write("Hello, Ferris"));
```

#### 1 `write!`
```rust
let mut buf = try!(fILE::create("foo.txt"));
write!(buf, "Hello {}!", "Ferris").unwrap();
```

#### 2 `BufReader`
```rust
fn new(inner: R) -> BufReader<R>;
fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> { ... };
fn read_line(&mut self, buf: &mut String) -> Result<usize> { ... };
fn split(self, byte: u8) -> Split<Self> where Self: Sized { ... };
fn lines(self) -> Lines<Self> where Self: Sized{ ... };

pub trait BufRead: Read {
    fn fill_buf(&mut self) -> Result<&[u8]>;
    fn consume(&mut self, amt: usize);
}

// example
let mut f = try!(File::open("foo.txt"));
let buffered_reader = BufReader::new(f);
```

#### 3 `BufWriter`

Just caches all wites until the BUfWriter goes out of scope, then writes them all at once.

#### 4 `StdIn`

```rust
let mut buffer = String::new();
try!(io::stdin().read_line(&mut buffer));
```

no need for BufReader.

#### 5 `StdInLock`
+ A "lock" on standard input mean only that current instance of `StdIn` can read from the terminal.
+ All `read` methods call `self.lock()` internally.
+ A `StdInLock` implements `Read` and `BufRead`

```rust
let lock: io::StdInLock = io::stdin().lock();
```

 #### 6 `StdOut`

 + implements `Write`
 + prefer use `print!` or `println!`

 #### 7 Special IO Structs

+ `repeat(byte: u8)`: A reader which will infinitely yield the specified byte. It will always fill the provided buffer.
+ `sink()`: "A writer which will move data into the void."
+ `empty()`: A reader which will always return Ok(0).
+ `copy(reader: &mut R, writer: &mut W) -> Result<u64>` copies all bytes from the reader into the writer.

### `Serde`

```rust
#![feature(custom_derive, plugin)]
#![plugin(serde_macros)]

extern crate serde;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
pub struct X { a: i32, b: String }

fn main() {
    let object = X { a: 6, b: String::from("half dozen") };
    let encoded = serde_json::to_string(&object).unwrap();
    // ==> the string {"a":6,"b":"half dozen"}
    let decoded: X = serde_json::from_str(&encoded).unwrap();
}
```

## Network

### 1 Socket

+ 一种基本的，通过网络发送和接受数据的方式，
    > IPC sockets 是 Unix 中的东西，易混淆
+ Layers socket-programming providers:
  + OS: System calls
  + pl: language special std lib
  + Higher-level networking libraries handling a specific protocol. such as HTTP

#### 1 Datagram Sockets (UDP)

+ User Datagram Protocol sockets
+ Stateless
+ at least once delivery, no guaranteed, no order, maybe receive more than once.
+ `send_to(addr)` and `recv_from()`

example code:

```rust
// Try to bind a UDP socket
let mut socket = try!(UdpSocket::bind("127.0.0.1:34254"));

// Try to receive data from the socket we've bound
let mut buf = [0; 10];
let (amt, src) = try!(socket.recv_from(&mut buf));

// Send a reply to the socket we just received data from
let buf = &mut buf[..amt];
buf.reverse();
try!(socket.send_to(buf, &src));

// Close the socket
drop(socket);
```

#### 2 Stream Sockets (TCP)

+ Transmission Control Protocol sockets
+ Stateful, need connection
+ inorder, exactly once, via packet sequence numbers.
+ package has ack
+ `listen` `streams`

##### `std::net::TcpStream`

client example code:

```rust
// Create a TCP connection
let mut stream = TcpStream::connect("127.0.0.1:34254").unwrap();

// Uses std::io::{Read, Write}

// Try to write a byte to the stream
let write_result = stream.write(&[1]);

// Read from the stream into buf
let mut buf = [0; 128];
let read_result = stream.read(&mut buf);

// ...
// Socket gets automatically closed when it goes out of scope

```

server example code:

```rust
let listener = TcpListener::bind("127.0.0.1:80").unwrap();

fn handle_client(stream: TcpStream) { /* ... */  }

// Accept connections and process them,
// spawning a new thread for each one.
for stream in listener.incoming() {
    match stream {
        Ok(stream) => {
            thread::spawn(move|| {
                // connection succeeded
                handle_client(stream)
            });
        }
        Err(e) => { /* connection failed */ }
    }
}

// close the socket server
drop(listener);
```

#### 3 `SocketAddr`

+ A socket address representation.
+ May be either IPv4 or IPv6.
+ Easily created using...

```rust
pub trait ToSocketAddrs {
    type Iter: Iterator<Item=SocketAddr>;
    fn to_socket_addrs(&self) -> Result<Self::Iter>;
}
```

### HTTP

> hyper 和课程中的表述已经发生了较大的变化，回头总结。

## Concurrent

### why concurrency hard?

+ `Sharing data`
+ `Data races`
+ `Synchronization`
+ `Deadlock`

> Deadlock: mutual exclusion, resource holding, no preemption, circular waiting

### rust thread

+ `std::thread`
+ `std::thread::JoinHandler` cannot be cloned
+ `panic!` Thread panic is unrecoverable from within the panicking thread
  + Only the thread that panics will crash
  + The thread will unwind its stack, cleaning up resources
  + The message passed to `panic` can be read from other thread!
+ get thread object: `handle.thread()`, `thread::curent()`

```rust
use std::thread;

let handle = thread::spawn(|| {
    thread::park();
    println!("hello world!");
});

println!("good night");
handle.thread().unpark();
println!("{:?}", handle.join().unwrap());
```

### `Send` `Sync`

+ Rust type system includes traits for enforcing certain concurrency guarantees.
+ `Send` a type can be safely transferred between threads.
  + have its ownership transferd across threads.
  + Noimplementing `Send` enforces that a type may not leave its original thread
+ `Sync` a type can be safely shared between threads
  + can't introduce memory unsafety when uded across multiple threads
  + all primitive types are `Sync`; all aggregate types containing only that are `Sync` are also Sync.
    + `T` is thread safe => `&T` and `&mut T`  is thread safe.
+ Both `Send` and `Sync` are marker traits, which don't implements any methods
+ rust safety checks is not guaranteed. Implementation should uphold the traits guarentees.
+ `Send` is auto- derived for all types whose member are all `Send`.
+ `Sync` is auto-derived for all types whose members are all `Sync`
  + remove an automatic derivation

```rust
impl !Send for Foo {}
impl !Sync for Foo {}
```

### Share Thread State

** error1 **

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}

// error: capture of moved value: `data`
//        data[i] += 1;
//        ^~~~
```

> why error? maybe have multi owners!

### `std::sync::Arc<T>` Atomic Reference-Counted pointer

+ like `Rc` but thread safety
+ also has a corresponding `Weak` Variant

** error2 **

```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone(); // Increment `data`'s ref count
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
```

+ like `Rc` `Arc has no interior mutability

### `Mutex`

> required revisit [mutex](https://github.com/cis198-2016s/slides/blob/gh-pages/10/content.md#mutexes)

+ short for Mutual Exclusion
+ ensure that a value can only be accessed by one thread at a time.
+ When a value is wrappted in a `Mutex`, you must call lock on the Mutex to get access to the value inside. This method returns a `LockResult`
+ If a thread acquires a mutex lock and then panics, the mutex is considered poisoned, as the lock was never released.
+ `lock()` return a `LockResult`
  + `Ok(MutexGuard)` the mutex was not poisoned and maybe used
  + `Err(PoisonError<MutexGuard>)`
+ a poisoned mutex can be access by calling `into_inner`, `get_ref`, `get_mut`

```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    // lock the data instead of lock the code
    let mut data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone(); // Increment `data`'s ref count
        thread::spawn(move || {
            // .lock will return a Result object
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
    // dont known when all of them finished!
}
```

+ `Mutex.lock()` acquire a mutex, blocking the current thread until it is able to do so
+ a `Mutex.lock()` will be released when go out of scope

#### `AtomicUsize`

+ An integer type which can be safely shared between threads

```rust
const fn new(v: usize) -> AtomicUsize;      // 
fn get_mut(&mut self) -> &mut usize;        // 此时 atomic 会保证其他线程均不可访问
fn into_inner(self) -> usize;               // 参数是 self，因而消费了自身，同时也表明是内存安全的
fn load(&self, order: Ordering) -> uszie;   // Ordering 参数制定了这个操作的内存语义
fn store(&self, val: usize, order: Ordering);   // Store a value into the atomic integer 
fn swap(&self, val: usize, order: Ordering) -> usize;   // 
fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize;
fn compare_exchange(
    &self, 
    current: usize, 
    new: usize, 
    success: Ordering, 
    failure: Ordering
) -> Result<usize, usize>   // store the new value into atomic integer if the current value is the same as the
                            // current value
fn compare_exchange_weak(
    &self, 
    current: usize, 
    new: usize, 
    success: Ordering, 
    failure: Ordering
) -> Result<usize, usize>   // this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms.
fn fetch_add(&self, val: usize, order: Ordering) -> usize;  // Adds to the current value, returning the previous value.
fn fetch_sub(&self, val: usize, order: Ordering) -> usize;
fn fetch_and(&self, val: usize, order: Ordering) -> usize;  // Bitwise "and" with the current value.
fn fetch_or(&self, val: usize, order: Ordering) -> usize;
fn fetch_xor(&self, val: usize, order: Ordering) -> usize;
```

#### `std::sync::atomic::Ordering`

原子类型的内存顺序。
Memory orderings limit the ways that both the compiler and CPU may reorder instructions around atomic operations.

+ [llvm memory model](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations)
+ [nomicon explain](https://doc.rust-lang.org/nomicon/atomics.html)

```rust
pub enum Ordering {
    Relaxed,    // 没有顺序限制，只有 atimic 操作
    Release,    // 其他线程采用 Acquire load 数据时，可以看到使用 Release 写入的数据
    Acquire,    // 
    AcqRel,     // load 时等价于 Acquire， store 时等价于 Release
    SeqCst      // 在 AcqRel 的基础上保证所有的线程以顺序进行执行
}
```

example code：

```rust
let an_atomic = Arc::new(AtomicUsize::new(0));
```

### `std::sync::mpsc`

> 如何实现多个消费者一个生产者的任务呢？
> 进一步地如何实现多个消费者多个生产者的任务呢？

+ Multi-Producer, Single-Consumer
+ three main types:
  + `Sender`
  + `SyncSender`
  + `Receiver`
+ `Sender` or `SyncSender` can send data to `Receiver`
+ Sender types may be cloned and given-to multi threadd to create multiple producers

```rust
use std::thread;
use std::sync::mpsc::channel;

fn main() {
    let (tx, rx) = channel();
    for i in 0..10 {
        let tx = tx.clone();
        thread::spawn(move|| {
            tx.send(i).unwrap();
        });
    }
    drop(tx);

    let mut acc = 0;
    while let Ok(i) = rx.recv() {
        acc += i;
    }
    assert_eq!(acc, 45);
}
```

#### [`std::sync::mpsc::Receiver`](https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv)

+ 实际上，在 Receiver 上使用 Mutex 加锁即可实现阻塞队列，思考在 rust 中这种实现的不同。

```rust
// Attempts to return a pending value on this receiver without blocking.
fn try_recv(&self) -> Result<T, TryRecvError>;

// Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.
fn recv(&self) -> Result<T, RecvError>;

// Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, 
// or if it waits more than  timeout.
fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError>;

// Returns an iterator that will block waiting for messages, 
// but never panic!. It will return None when the channel has hung up.
fn iter(&self) -> Iter<T>;

// Returns an iterator that will attempt to yield all pending values. 
// It will return None if there are no more pending values or if the channel has hung up.
// The iterator will never panic! or block the user by waiting for values.
fn try_iter(&self) -> TryIter<T>;
```

#### [`std::sync::mpsc::Sender](https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html)

```rust
// Attempts to send a value on this channel, returning it back if it could not be sent. never block.
// An unsuccessful send would be one where the corresponding receiver has already been deallocated.
fn send(&self, t: T) -> Result<(), SendError<T>>
```

failed example:

```rust
let (tx, rx) = channel();

// This send is always successful
tx.send(1).unwrap();

// This send will fail because the receiver is gone
drop(rx);
assert_eq!(tx.send(1).unwrap_err().0, 1);
```

#### ASync

+ `(Sender<T>, Receiver<T>) = channel<T>()`
+ `Sender` is an asynchronous channel
+ Sending data across the channel is never block the sending thread, `Sender` has a conceptually-infinite buffer

#### Sync

+ `(SyncSender<T>, Receiver<T>) = sync_channel<T>()`
+ `SyncSender` is synchronized, block when you send a message, until the buffer space available.

### `std::sync::RwLock<T>`

+ A read write lock
+ Like `Mutex` but separate modes for reading and writing access
+ Allow data access to many readers or one writer
+ Inner `T` must be `Send + Sync`
+ Poisoning only occurs if a writer panics
+ Useful if you have many threads requesting reads and few requesting writes
+ `RwLock` only works on `Sync` types, otherwise you need mutual exclusion
+ `RefCell`, also encoding single-write-multiple-read idea
+ As with `Mutex` an `RwLock` could cause deadlock under certain conditions

### `std::sync::Barrier`

+ A type to allow multiple threads to synchronize on a computation
+ create for a fixed number of thread
+ Thread may call `wait` on a copy of `Barrier` to report their readiness
+ blocks `n - 1` threads and wakes all blocked threads when the `n`th thread reports

+ how do you ensure all threads see the same data:
  + reader may want to be guaranteed that all writes have completed before they read
  + Able to synchronize on this action with a `Barrier`

### `std::sync::Condvar`

+ a "condition variable"
+ Blocks a thread so that it consumes no CPU time while waiting for an event.
+ Generally associated with a `Mutex` wrapping some boolean predicate which is the blocking predicate.
+ a nice way to put a thread "on hold", does not require holding any locks, not waste CPU time.
+ just for implemented for producer/consumer problem

> rust 中如何解决一个生产者消费者问题，实现一个阻塞队列。

### `std::sync::Once`

+ A primitive to run a one-time global initialization.
+ Regardless of how many times `once.call_once(function)` is called, only the first one will execute.
+ Allows the code to attempt initialization more than once.
+ Useful for doing one-time initialization to call foreign functions.

## Rust Atomics

+ atomic: apears to occur "instantly" from the program's perspective
+ rust's atomic primitives define this behavior at the type level
+ Four kinds: `AtomicUsize`, `Isize`, `Bool`, `Ptr`
+ use same ordering as `LLVM`， and the same atomic model as C11

## Rayon

+ Two primary features
  + Parallel iterators: take iterator chains and execute them in parallel
  + `rayon::join` converts recursive divide and conquer iterators to execute in parallel

### Parallel Iterators

```rust
// Increment all values in a slice
use rayon::prelude::*;
fn increment_all(input: &mut [i32]) {
    input.par_iter_mut()
         .for_each(|p| *p += 1);
}
```

### Recursive Divide and Conquer

+ Recursive divide-and-conquer problems can be parallelized using Rayon's `join` method
+ Parallel iterators are built on this method,and par_iter() abstracts over it

> 补充更多 Rayon 的内容

## futures and tokio

> 补充更多内容

## Unsafe Rust

### why unsafe

rust 的安全性检查相对是比较保守的使得很多安全的代码无法通过 rust 的安全性检查。
unsafe 特性提供了一种绕过 rust 的编译器安全性检查的方法，使得我们可以：

+ 和其他的语言进行交互， 比如 `C`
+ 编写一些 `std` 库不提供的底层方法
+ 使用一些特殊的 ownership 交互

### safe and unsafe in rust

#### Dangerous but safe in rust

+ Deadlocks
+ memory leaks
+ Interger overflow
+ exiting without running destructors

#### this dangerous will be checked by rust compile

+ Data races
+ Dereferencing invalid pointers
+ Reading uninitialized memory
+ Creating invalid primitives

#### `unsafe` let you do:

+ dereference raw pointers
+ mutate `static` variables
+ implement `unsafe` traits
+ call `unsafe` functions

### 基本用法

+ unsafe code 应当使用 `unsafe` 关键字包装
+ 一个函数可以定义为 `unsafe` 的

### Borrow split problem

+ Struct borrows can be split to allow multiple mutable borrows

```rust
struct Point {
    x: i32,
    y: i32,
}

let mut p = Point { x: 0, y: 1 };
let x1 = &mut p.x;
let y1 = &mut p.y;
*x1 += 1;
*y1 += 1; // OK
```

+ arrays and slices can't borrow split

```rust
let mut arr = [1, 2, 3];
let x = &mut arr[0];
let y = &mut arr[1];
//  ^ cannot borrow `arr[..]` as mutable more than once at a time
let z = &arr[2];
```

+ unsafe can allow us to overcome this limitation

```rust
fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
    let len = self.len();
    let ptr = self.as_mut_ptr();
    assert!(mid <= len);
    unsafe {
        (from_raw_parts_mut(ptr, mid),
         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
```

### Raw Pointers

+ rust has two types of C-like "raw-pointers"
  + `*const T`
  + `*mut T`
+ unsafe to dereference
+ no ownership semantics
+ can be initialized to null with `null()` and `null_mut()`

```rust
// Reference coercion
let mut x = 0i32;
let const_ptr = &x as *const i32;
let mut_ptr = &mut x as *mut i32; // Allowed to alias pointers

let box_y = Box::new(1);
let raw_y = &*box_y as *const i32; // Does not consume `box_y`

// Box consumption
let raw_y_2 = Box::into_raw(box_y);

// ... to properly clean up, later ...
unsafe { drop(Box::from_raw(raw_y_2)); }
```

+ Raw Pointers may need to be deallocated manually
+ if used after lifetime expired may caurse segmentation fault

### Unique

+ A wrapper, around `*mut T` indicate that the `Unique` struct owns the pointer.
+ Confers regular Rust ownership semantics, unlike `*mut T`
+ Implies `T` should not be modified without a unique path to `T`
+ Unsafe to create, dereference
+ useful for building abstractions such as `Box`

```rust
#![feature(unique)]
use std::ptr::Unique;

let mut x = 0i32;
let mut_ptr = &mut x as *mut i32;
unsafe {
    let unique_ptr = Unique::new(mut_ptr);
}
```

### Shared

+ A Wrapper around `*mut T` indicate that the `Shared` struct has shared ownership of the pointer.
+ Conders ownership semantics, unlike `*mut T`
+ unsafe to create dereference
+ Useful for building abstractions such as `Rc`, `Arc`

### UnsafeCell

+ A wrapper around a T that provides interior mutability.

### Uninitialized Memory

### Leaking Memory

+ Leaking memory is a safe operation, and can be done with `std::mem::forget()`.

### Transmutation

+ type system is too pesky
+ `mem::transmute<T, U>` takes a value of type `T` and reinterprets it to be of type `U`

### [Vec](https://github.com/cis198-2016s/slides/blob/gh-pages/12/content.md#vec-layout)

## Implementing `Vec`

+ Let's take a deep dive into how `std::vec::Vec` is actually implemented.
+ This code will only compile on nightly, since it uses unstable features.
+ Warning: this is going to get pretty advanced.

&sup1;All content taken from [The Rustonomicon](https://doc.rust-lang.org/nomicon/)

### `Vec` Layout

+ A `Vec` has three parts:
  + a pointer to the allocated data
  + the size of the allocation
  + the number of elements in the vector
+ Naively, this translates into this struct:

```rust
pub struct Vec<T> {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
```

+ Simple, right?
+ Sadly, this won't quite work.
+ Some lifetime variance problems:
  + An `&Vec<&'static str>` can't be used in place of an `&Vec<&'a str>`.
+ Some drop checker problems:
  + `*mut T` conveys no ownership.
  + The drop checker assumes we own no values of type `T`.

+ Using a `Unique` in place of an `*mut T` solves these problems!
  + `Unique` conveys ownership.
  + It also lets us be `Send` & `Sync` if `T` is, and auto-derefs to `*mut T`.
  + It also is guaranteed to never be null, allowing null pointer
        optimizations.

```rust
#![feature(unique)]
use std::ptr::{Unique, self};

pub struct Vec<T> {
    ptr: Unique<T>,
    cap: usize,
    len: usize,
}
```

+ Now that we use a `Unique` to store our data, what does an empty `Vec` look
    like?
  + It can't have a null pointer...
  + ...but we don't want to allocate any data!
+ Turns out, we can just fill the `Vec` with garbage!
+ `cap` is 0, so we don't need to worry about accidentally accessing garbage.
+ `std` exposes a value as `alloc::heap::EMPTY` to represent this value.

```rust
#![feature(alloc, heap_api)]
use alloc::heap::EMPTY;

impl<T> Vec<T> {
    fn new() -> Self {
        unsafe {
            assert!(mem::size_of::<T>() != 0);
            Vec { ptr: Unique::new(heap::EMPTY as *mut _),
                  len: 0,
                  cap: 0 }
        }
    }
}
```

???
We need to assert that `T` is not a ZST, since apparently ZSTs will break
everything horribly at this point in the implementation.

+ Now that we can allocate no space, we need to figure out how to allocate
    space.
+ The `heap` module is our friend here.
  + This lets us talk to Rust's allocator (jemalloc by default).
+ We also need to figure out how to handle an out-of-memory condition.
  + `panic!` is no good, since it can cause allocations.
  + `std` usually executes an illegal instruction to crash the program.
+ We'll define an out-of-memory error like so:

```rust
fn oom() { ::std::process::exit(-9999); }
```

+ Our logic for growing the `Vec` is roughly this:

```rust
if cap == 0 {
    allocate()
    cap = 1
} else {
    reallocate()
    cap *= 2
}
```

+ Unfortunately, this is not so easy in practice...

+ Because of some serious LLVM shenanigans, a `Vec` can only contain
    `isize::MAX` elements.
  + This _also_ means we only care about byte-sized allocations, since e.g.
        `isize::MAX u16s` will only just fit in memory.
+ Zero-size types are also tricky to allocate due to LLVM.
+ tl;dr Read the ch. 10 in the Rustonomicon, this info is totally out of scope.

+ Time to actually allocate data.
+ The `heap` module exposes an `allocate` function that puts data into the heap.
+ It also exposes a `reallocate` function that takes an existing allocation and
    resizes it.
+ Our pseudocode from a few slides ago can now be implemented, with a few extra
    parts.

```rust
fn grow(&mut self) {
    unsafe {
        let align = mem::align_of::<T>();
        let elem_size = mem::size_of::<T>();
        let (new_cap, ptr) = if self.cap == 0 {
            let ptr = heap::allocate(elem_size, align);
            (1, ptr)
        } else {
            let new_cap = self.cap * 2;
            let old_num_bytes = self.cap * elem_size;
            assert!(old_num_bytes <=
                               (::std::isize::MAX as usize) / 2);
            let new_num_bytes = old_num_bytes * 2;
            let ptr = heap::reallocate(*self.ptr as *mut _,
                            old_num_bytes, new_num_bytes, align);
            (new_cap, ptr)
        }
    };

    if ptr.is_null() { oom(); }
    self.ptr = Unique::new(ptr as *mut _);
    self.cap = new_cap;
}
```

???
`align_of` specifies the alignment of a type.
We can always assume `self.cap < isize::MAX`, so no need to check this when we
assign `new_cap`. Assertion against `old_num_bytes` ensures we don't overflow
the vector's capacity. If `allocate` or `reallocate` fails, we get `null` back.

+ Actual functionality! Woo!
+ `push` only needs to check if the `Vec` is full to grow, write to the next
  available index, and increment the length.
  + Be careful! This method shouldn't read from the memory it writes to, since
      this is uninitialized.
  + Even calling `v[idx] = x` will try to drop the old value of `v[idx]`.
+ To avoid reading uninitialized memory, use `ptr::write`.

```rust
pub fn push(&mut self, elem: T) {
    if self.len == self.cap { self.grow(); }
    unsafe {
        ptr::write(self.ptr.offset(self.len as isize), elem);
    }

    self.len += 1;
}
```

???
`self.ptr.offset` does pointer arithmetic to compute an offset from a pointer.
The above usage writes to the memory slot just past the end of the vector's last
element.

+ With `pop`, the data being removed is initialized, so we can read it.
+ Unfortunately, just moving the value out doesn't work.
  + This would leave memory uninitialized.
+ `ptr::read` does the trick here, copying the data out.

```rust
fn pop(&mut self) -> Option<T> {
    if self.len == 0 {
        None
    } else {
        self.len -= 1;
        unsafe {
            Some(ptr::read(self.ptr.offset(self.len as isize)))
        }
    }
}
```

+ Now we want to be able to deallocate a `Vec`.
+ This actually requires a manual implementation of `Drop`.
+ The whole `Vec` can be deallocated by popping it down to zero, then calling
    `heap::deallocate`.
+ Obviously, we shouldn't try to deallocate anything if the `Vec` has no
    memory allocated.

```rust
impl<T> Drop for Vec<T> {
    fn drop(&mut self) {
        if self.cap != 0 {
            while let Some(_) = self.pop {}
            let align = mem::align_of::<T>();
            let elem_size = me::size_of::<T>();
            let num_bytes = elem_size * self.cap;
            unsafe {
                heap::deallocate(*self.ptr as *mut _, num_bytes,
                                                         align);
            }
        }
    }
}
```

### `Vec` `Deref`

+ How do you implement`Deref` & `DerefMut` for `Vec`?
+ For `Vec<T>`, these methods return an `&[T]`/`&mut [T]`, respectively.
+ Basically, this boils down to calling `::std::slice::from_raw_parts(*self.ptr,
    self.len)`.

### `Vec` Insert & Remove

+ Inserting into a `Vec` needs to shift all elements over to the right from the
    given index.
+ Fortunately, we have an easy way to do this using `ptr::copy`, which is like
    `memmove` from C.
+ `ptr::copy` copies some chunk of memory from here to there, and the source and
    destination may overlap.
+ Inserting at index `i` shifts `[i .. len]` to `[i+1 .. len+1]`, using the old
    `len`.

```rust
pub fn insert(&mut self, index: usize, elem: T) {
    assert!(index <= self.len);
    if self.cap == self.len { self.grow(); }

    unsafe {
        if index < self.len {
            ptr::copy(self.ptr.offset(index as isize),
                      self.ptr.offset(index as isize + 1),
                      self.len - index);
        }
        ptr::write(self.ptr.offset(index as isize), elem);
        self.len += 1;
    }
}
```

???
We're allowed to insert at `index == len`, since that's just `push`

+ Removing elements by index just behaves in the opposite direction.
+ Shift all elements from `[i+1 .. len+1]` to `[i .. len]` using the _new_
    `len`.

```rust
pub fn remove(&mut self, index: usize) -> T {
    assert!(index < self.len);
    unsafe {
        self.len -= 1;
        let t = ptr::read(self.ptr.offset(index as usize));
        ptr::copy(self.ptr.offset(index as isize + 1),
                  self.ptr.offset(index as isize),
                  self.len - index);
        t
    }
}
```

### [Rust FFI](https://doc.rust-lang.org/book/ffi.html)

+ FFI: Foreign Function Interface.
+ FFI means calling one language from another.
+ For us, this means:
  + Rust calling C
  + C calling Rust
  + Other languages (e.g. Python/Ruby) calling Rust
+ Why C? C is the de facto language used for FFI.
  + Often referred to as the programming _lingua franca_.

> 比较核心的感觉是 rust 调用 C， Python、js 调用 Rust

#### Calling C from Rust

+ Why?
  + Sometimes you need to call another library - e.g. OpenSSL - that would be too costly to reimplement in Rust.
  + Sometimes you need to interface with a particular language; many
    native programming languages can make C bindings.
+ Calling foreign functions from Rust is `unsafe`!
  + Because, of course, C is unsafe.

+ Compile C to static libraries (`.a`/`.lib`).
  + `cc -c -o foo.o foo.c`
  + `ar rcs libfoo.a foo.o`
+ Or to dynamic libraries (`.so`/`.dylib`/`.dll`).
  + `cc -c -fPIC -o foo.o foo.c`
  + `cc -shared -fPIC -o libfoo.so foo.o`

+ In C:

```c
int32_t foo() { return 10; }
```

+ In Rust:

```rust
#[link(name = "foo", kind = "static")]  // links libfoo.a.
extern {
    fn foo() -> i32;
}

#[link(name = "foo")]  // links libfoo.so.
extern {               // By default, this is also
    fn foo() -> i32;   // statically linked.
}
```

+ Calling foreign functions is unsafe:

```rust
fn main() {
    println!("foo: {}", unsafe { foo() });
}
```

+ In C APIs, it's common to use incomplete struct definitions to define types whose implementation shouldn't be exposed to users.
  + These can't be instantiated by the user.

```c
struct OpaqueThing;
```

+ To represent a type like this in Rust (for FFI), we want to make a type that we can't instantiate! So we do this:

```rust
enum OpaqueThing { }
```

+ Now, we can't have one of these, but we _can_ have a pointer to one: `*mut OpaqueThing`.
  + Pointers to opaque types are very common in C interfaces.

### Calling Rust from C

+ Why?
  + Writing particularly dubiously-safe code in Rust.
  + Writing any part of a C program in a nicer language.

#### Rust from C: `#[repr(C)]`, `extern "C"`

+ Rust has its own rules about memory layout and calling convention, which are different from C's.
+ In order to call from C (**or any other language!**), we have to use C rules. (C doesn't have generics, enums with fields, etc.)

```rust
#[repr(C)]
pub enum Color { Red = 1, Blue, Green = 5, Yellow }

#[repr(C)]
pub struct Bikeshed { height: f64, area: f64 }

extern "C" pub fn paint(bs: Bikeshed, c: Color) { /* ... */ }
```

+ Use opaque structs to hide stuff that C can't use:

```rust
struct X<T>(T); // C doesn't have generics.

#[repr(C)]
pub struct Xi32(X<i32>); // This struct hides the type parameter.
```

#### Rust from C: Static Linking

+ Compile Rust to static libraries (`.a`) and link at build time.
  + Compile to `target/release/libfoo.a`.
+ `Cargo.toml`:

```toml
[lib]
crate-type = ["staticlib"]
```

+ $ `cc -Ltarget/release -lfoo -o main main.c`

```c
#include <stdint.h>

int32_t foo(); // Function prototype for Rust function

int main() {
    printf("foo() -> %d\n", foo());
}
```

#### Rust from C: Dynamic Linking

+ Compile Rust to dynamic libraries (`.so`) and load at runtime.
  + Compile to `target/release/libfoo.so`.
+ `Cargo.toml`:

```toml
[lib]
crate-type = ["dylib"]
```

+ In C:

```c
#include <dlfcn.h>

int main() {
    void *handle = dlopen("target/release/libfoo.so", RTLD_LAZY);
    int32_t (*foo)() = dlsym(handle, "foo"); // get function ptr
    // plus error checking

    printf("foo() -> %d\n", foo());

    dlclose(handle);
}
```

### Calling Rust from Python

+ Why?
  + Many languages (Python, Ruby, etc.) are extremely slow compared with
    C and Rust.
  + Traditionally, high-performance functions are written in C or
    C++, and called from scripting languages.
  + Rust is an ideal alternative high-performance language.
  + Great for data processing, scientific computing, multithreaded code, etc.
+ Compile Rust to a dynamic library (`.so`/`.dylib`/`.dll`).
+ In Python:

```python
import ctypes
libfoo = ctypes.CDLL("target/release/libfoo.so")
print("foo() -> {}".format(libfoo.foo()))
```

## [Macros](https://danielkeep.github.io/tlborm/book/)

### C Macros Limited

+ does a direct token level substitudion
+ no variables, types, operators
+ can't be recursive.
+ include macro make the file bigger and bigger

### Rust Syntax Extension

+ Rust has a generalized system called _syntax extensions_. Anytime you see one of these, it means a syntax extension is in use:
  + `#[foo]` and `#![foo]`
    + These are used for [attributes][].
  + `foo! arg`
    + Always `foo!(...)`, `foo![...]`, or `foo!{...}`
    + _Sometimes_ means `foo` is a macro.
  + `foo! arg arg`
    + Used only by `macro_rules! name { definition }`

+ The third form is the one used by macros, which are a special type of syntax extension - defined within a Rust program.

+ These can also be implemented by _compiler plugins_, which have much more power than macros.

### Main deference of Macro

1. `C` Token Streams
1. `rust` Token Tree

### Implementation

#### Capture

```rust
macro_rules! macro_name {
    ( $name1:kind, ... ) => { ... },
    ( $name1:kind, $name2:kind ) => { ... },
}
```

possible kind:

1. `item`:  function, struct, module
1. `block`: a block (i.e. `{ some; stuff; here }`)
1. `stmt`:  a statement
1. `expr`:  an expression
1. `ty`:    a type
1. `ident`: an identifier
1. `path`:  a path (e.g. `foo`, `::std::mem::replace`, ... )
1. `meta`:  a meta item; the things that go inside `#[...]`
1. `tt`:    a single token tree

#### Repetition

+ If we want to match a list, a variable number of arguments, etc., we can't do this with the rules we've seen so far.
  + _Repetitions_ allow us to define repeating subpatterns.
  + These have the form `$ ( ... ) sep rep`.
    + `$` is a literal dollar token.
    + `( ... )` is the paren-grouped pattern being repeated.
    + `sep` is an *optional* separator token.
      + Usually, this will be `,` or `;`.
    + `rep` is the *required* repeat control. This can be either:
      + `*` zero or more repeats.
      + `+` one or more repeats.
  + The same pattern is used in the output arm.
    + The separator doesn't have to be the same.

+ example

```rust
macro_rules! myvec {
    ( $( $elem:expr ),* ) => {
        {
            let mut v = Vec::new();
            $( v.push($elem); )*
            v
        }
    }
}
println!("{:?}", myvec![3, 4]);
```

#### Match

+ Macro rules are matched in order.
+ The parser can never backtrack.

```rust
macro_rules! dead_rule {
    ($e:expr) => { ... };
    ($i:ident +) => { ... };
}
```

always match in the first expr, second never get.

#### Hygiene

+ Rust macros are _partially hygenic_.
  + Hygenic with regard to most identifiers.
    + These identifiers get a special context internal to the macro expansion.
  + NOT hygenic: generic types (`<T>`), lifetime parameters (`<'a>`).

```rust
macro_rules! using_a {
    ($e:expr) => {     { let a = 42;  $e }  }
} // Note extra braces ^                 ^

let four = using_a!(a / 10); // this won't compile - nice!
```

+ We can imagine that this expands to something like:

```rust
let four = { let using_a_1232424_a = 42; a / 10 };
```

+ But if we _want_ to bind a new variable, it's possible.

```rust
macro_rules! using_a {
    ($a:ident, $e:expr) => {  { let $a = 42;  $e }  }
}        // Note extra braces ^                  ^

let four = using_a!(a, a / 10); // compiles!
```

+ This expands to:

```rust
let four = { let a = 42; a / 10 };
```

#### Nested and Recursive Macros

A macro calls another macro (or itself), this is fine.


```rust
macro_rules! each_tt {
    () => {};
    ( $_tt:tt $($rest:tt)* ) => { each_tt!( $($rest)* ); };
}
```

+ The compiler's recursion limit can be changed with `#![recursion_limit="64"]` at the crate root.
  + 64 is the default.
  + This applies to all recursive compiler operations, including auto-dereferencing and macro expansion.

#### Macro Debug

+ Rust has an unstable feature for debugging macro expansion.
  + Especially recursive macro expansions.

  ```rust
  #![feature(trace_macros)]
  macro_rules! each_tt {
      () => {};
      ( $_tt:tt $($rest:tt)* ) => { each_tt!( $($rest)* ); };
  }

  trace_macros!(true);
  each_tt!(spim wak plee whum);
  trace_macros!(false);
  ```

  + This will cause the compiler to print:

  ```rust
  each_tt! { spim wak plee whum }
  each_tt! { wak plee whum }
  each_tt! { plee whum }
  each_tt! { whum }
  each_tt! {  }
  ```

+ More tips on macro debugging in [TLBORM 2.3.4](https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html)

### Scoping

+ Macro scoping is unlike everything else in Rust.
  + Macros are immediately visible in submodules:

  ```rust
  macro_rules! X { () => {}; }

  mod a {  // Or `mod a` could be in `a.rs`.
      X!(); // valid
  }
  ```

  + Macros are only defined _after_ they appear in a module:

  ```rust
  mod a { /* X! undefined here */ }

  mod b {
      /* X! undefined here */
      macro_rules! X { () => {}; }
      X!(); // valid
  }

  mod c { /* X! undefined */ } // They don't leak between mods.
  ```

+ Macros can be exported from modules:

  ```rust
  #[macro_use]  // outside of the module definition
  mod b {
      macro_rules! X { () => {}; }
  }

  mod c {
      X!(); // valid
  }
  ```
+ Or from crates, using `#[macro_export]` in the crate.

+ There are a few other weirdnesses of macro scoping.
  + See [TLBORM 2.3.5](https://danielkeep.github.io/tlborm/book/mbe-min-scoping.html) for more.

+ In general, to avoid too much scope weirdness:
  + Put your crate-wide macros at the top of your root module (`lib.rs` or `main.rs`).

### Macro CallBack

+ Because of the way macros are expanded, "obviously correct" macro invocations like this won't actually work:

  ```rust
  macro_rules! expand_to_larch {
      () => { larch };
  }

  macro_rules! recognise_tree {
      (larch) => { println!("larch") };
      (redwood) => { println!("redwood") };
      ($($other:tt)*) => { println!("dunno??") };
  }

  recognise_tree!(expand_to_larch!());
  ```

  + This will be expanded like so:

  ```rust
  -> recognize_tree!{ expand_to_larch ! ( ) };
  -> println!("dunno??");
  ```

  + Which will match the third pattern, not the first.

+ This can make it hard to split a macro into several parts.
  + This isn't always a problem - `expand_to_larch ! ( )` won't match an `ident`, but it _will_ match an `expr`.

+ The problem can be worked around by using a _callback_ pattern:

  ```rust
  macro_rules! call_with_larch {
      ($callback:ident) => { $callback!(larch) };
  }

  call_with_larch!(recognize_tree);
  ```

  + This expands like this:

  ```rust
  -> call_with_larch! { recognise_tree }
  -> recognise_tree! { larch }
  -> println!("larch");
  ```

### Macro TT Match

+ This is one of the most powerful and useful macro design patterns.
  It allows for parsing fairly complex grammars.

+ A _tt muncher_ is a macro which matches a bit at the beginning of
  its input, then recurses on the remainder of the input.
  + `( $some_stuff:expr $( $tail:tt )* ) =>`
  + Usually needed for any kind of actual language grammar.
  + Can only match against literals and grammar constructs which can be captured by `macro_rules!`.
  + Cannot match unbalanced groups

```rust
macro_rules! mixed_rules {
    () => {}; // Base case
    (trace $name:ident ; $( $tail:tt )*) => {
        {
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);  // Recurse on the tail of the input
        }
    };
    (trace $name:ident = $init:expr ; $( $tail:tt )*) => {
        {
            let $name = $init;
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);  // Recurse on the tail of the input
        }
    };
}
```

### Rust Macro Problems

+ Macros are pretty great - but not perfect.
  + Macro hygiene isn't perfect.
  + The scope of where you can use a macro is weird.
  + Handling crates inside of exported macros is weird.
  + It's impossible to construct entirely new identifiers
    (e.g. by concatenating two other identifiers).
+ A new, incompatible macro system may appear in future Rust.
  + This would be a new syntax for writing syntax extensions.
