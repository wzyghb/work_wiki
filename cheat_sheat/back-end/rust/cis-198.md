
## Overview

### why rust
+ Fast (naive code, no garbage collector, most abstractions has zero cost, fine-grained control over lots of things)
+ Safe (no null, no uninitialized memory, no dangling pointers, no double free errors, no manual memory management)
+ Functional (First-class functions, Trait-based generics, Algebraic datatypes, Pattern matching)

### Tools

#### Rustc

#### Cargo

+ `cargo new project_name`
+ `cargo new project_name --bin`
+ `cargo build`
+ `cargo test`

##### `Cargo.toml`

```
[package]
name = "rust"
version = "0.1.0"
authors = ["ddd@xxx.com"]

[dependencies]
uuid = "0.1"
rand = "0.3"

[profile.release]
opt-level = 3
debug = false

```

####

### Basic rust syntax

#### Variable Bindings

```rust
let x = 17;
let x: i16 = 17;
let mut y = 5;
y += 1;
let (a, b) = ("foo", 12);
```

#### Expressions

+ Everything is an expression: something which returns a value.
+ `nothing` type is called `unit`, which is written `()`
+ A expression appending a semicolon return `()`.

```rust
let y = if x > 0 { "greeter" } else { "less" }
```
 
 #### Comments

 ```rust
 /// docstring comments
 /// 
 /// `rustdoc` use docstring comments to generate documentatiion, support **Markdown** formatting.
 ///
 fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
 ```

#### Types

##### Primitive Types

+ bool
+ char 'c' '狗' is Unicodel
+ Numerics:
    - i8, i16, i32, i64, isize
    - u8, u16, u32, u64, usize
    - f32, f64
    - isize and usize are the size of pointers, have machine dependencies
    - Literial splled 10i8, 10u16 10.0f32, 10usize
+ Arrays, slices, str, tuples
    - Array: [T; N] cannot be resize, access will be bounds-checked at runtime
    - Slices: &[T] a "view" into an array by reference, created directly, borrowed from other variables
    - Strings: String, &str
    - Tuples: fixed size, ordered, heterogeneous list, let bindings desctructure
+ Vec<T>
```rust
let init_arr = [2; 32];
let arr = [1, 2, 3, 4, 5];
let total_slice = &arr;
let total_slice = &arr[..];
let partial_slice = &arr[2..5];

let s: &str = "hello";
let s2: String = "hello".to_string();
let s3: String = String::from("hello");
let s4: &str = &s3

let x: i32 = 100;
let y: u32 = x as u32;
```

#### Functions

```rust
fn square_bad(n: i32) -> i32 {
    n * n
}

let x: fn(i32) -> i32 = square_bad;
fn apply_twice(f: &Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

apply_twice(&square_bad, 3);
```

#### Marcros!
+ `print!`, `println!`
+ `format!`
+ `panic!`
+ `assert!`, `assert_eq!`
+ `unreachable!`
+ `unimplemented!`

#### Match Statements

+ `...` specify a range of values
+ `_` bind against any value
+ `if-let`
+ `while-let`
+ inner bindings

```rust
let x = 3;
let y = -3;

match (x, y) {
    (1, 1) => println!("one"),
    (2, j) => println!("two, {}", j),
    (_, 3) => println!("three"),
    (i, j) if i > 5 && j < 0 => println!("On guard!"),
    (_, _) => println!(":<"),
}

let x = 17;

match x {
    0 ... 5 => println!("zero through five (inclusive)"),
    _ => println!("You still lose the game."),
}

let result = make_request();

if let Resultish::Err(s) = result {
    println!("Total and utter failure: {}", s);
} else {
    println!("ok.");
}

while let Resultish::Err(s) = make_request() {
    println!("Total and utter failure: {}", s);
}

#[derive(Debug)]
enum A { None, Some(B) }
#[derive(Debug)]
enum B { None, Some(i32) }

fn foo(x: A) {
    match x {
        a @ A::None              => println!("a is A::{:?}", a),
        ref a @ A::Some(B::None) => println!("a is A::{:?}", *a),
        A::Some(b @ B::Some(_))  => println!("b is B::{:?}", b),
    }
}

foo(A::None);             // ==> x is A::None
foo(A::Some(B::None));    // ==> a is A::Some(None)
foo(A::Some(B::Some(5))); // ==> b is B::Some(5)
```

## Ownership, Borrowing, Lifetimes

> 以后再总结

+ Ownership checked at compile time, no running time costs
+ A piece of data can only hava one owner at a time
+ when bingding goes out of scope,bound data is released automatically
+ move semantics
+ Multiple Lifetime Parameters
+ `'static` a reference may be kept for the lifetime of the entire program, never go out of scope, `'str` is `'static`

```rust
struct Pizza(Vec<i32>);
struct PizzaSlice<'a> { pizza: &'a Pizza, index: u32 }
struct PizzaConsumer<'a, 'b: 'a> { // says "b outlives a"
    slice: PizzaSlice<'a>, // <- currently eating this one
    pizza: &'b Pizza,      // <- so we can get more pizza
}

fn get_another_slice(c: &mut PizzaConsumer, index: u32) {
    c.slice = PizzaSlice { pizza: c.pizza, index: index };
}

let p = Pizza(vec![1, 2, 3, 4]);
{
    let s = PizzaSlice { pizza: &p, index: 1 };
    let mut c = PizzaConsumer { slice: s, pizza: &p };
    get_another_slice(&mut c, 2);
}
```

1. 定义在 struct、返回值、enum、Type 中的引用类型必须规定好 Lifetime 参数。函数中有 lifetime elision 但有可能不够。
2. 维持一个内存对象的指针和引用是危险的，主要来自于以下两个方面：
    1. 指针指向的一个已经离开可见范围的对象。
    2. 指针指向一个已经修改到别处的对象。

可以将 Lifetime 认为是程序中一个可见范围的名称，当一个 reference 存在一个 lifetime 时，我们认为他在这整个范围内是合法的。
不同情况下，reference 有不同的必须或可以合法的范围。整个 lifetime 系统从另一方面讲，知识一种限定解决系统，管理每个 refenece 的可见范围。当发现 lifetime 的集合满足所有的限制时，你的程序便可以编译，否则，你会快速给你错误信息。

在函数内部，编译器可以获得足够的信息来处理所有的 lifetime，但是对于整个 type 和 API 层，编译器则无法获得全部的信息，需要你来告诉他一些信息。

指针错误是全局的，难以发现和处理。rust 使用 lifetime，使得我们可以在函数内部发现和处理这些问题。rust 可以保证，没有对象会在 free 后还被使用，以及还有外部指针指向它时，被修改。


## Data Struct

### Struct
+ struct may not be partially-initialized
+ do not have field-level mutability
+ stucts fields are private by default - can only be accessed from within module where the struct is declared
+ tuple structs

```rust
pub struct Point {
    x: i32,
    y: i32,
}

match p {
    Point { x, y } => println!("({}, {})", x, y)
}

match p {
    Point { y, .. } => println!("{}", y)
}

struct Foo { a: i32, b: i32, c: i32, d: i32, e: i32 }

let mut x = Foo { a: 1, b: 1, c: 2, d: 2, e: 3 };
let x2 = Foo { e: 4, .. x };

// Useful to update multiple fields of the same struct:
x = Foo { a: 2, b: 2, e: 2, .. x };

struct Color(i32, i32, i32);

let mut c = Color(0, 255, 255);
c.0 = 255;
match c {
    Color(r, g, b) => println!("({}, {}, {})", r, g, b)
}
// Not equatable
struct Meters(i32);
struct Yards(i32);

// May be compared using `==`, added with `+`, etc.
type MetersAlias = i32;
type YardsAlias  = i32;

struct Unit;
let u = Unit;
```

### Enums

+ No data
+ Named data
+ Unnamed ordered data

```rust
enum Resultish {
    Ok,
    Warning { code: i32, message: String },
    Err(String)
}

match make_request() {
    Resultish::Ok =>
        println!("Success!"),
    Resultish::Warning { code, message } =>
        println!("Warning: {}!", message),
    Resultish::Err(s) =>
        println!("Failed with error: {}", s),
}
```

### Method

+ `&self`, `&mut self`, `self`

```rust
impl Point {
    fn distance(&self, other: Point) -> f32 {
        let (dx, dy) = (self.x - other.x, self.y - other.y);
        ((dx.pow(2) + dy.pow(2)) as f32).sqrt()
    }

    fn translate(&mut self, x: i32, y: i32) {
        self.x += x;
        self.y += y;
    }

    fn mirror_y(self) -> Point {
        Point { x: -self.x, y: self.y }
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.distance();
}

```

### Associated Functions

```rust
impl Point {
    fn new(x: i32, y: i32) -> Point {
        Point { x: x, y: y }
    }
}

fn main() {
    let p = Point::new(1, 2);
}
```


### Recursive Types

#### Boxes

+ box: a general term for one of Rust's ways of allocating data on the heap
+ Box<T> is a heap pointer with exactly one owner
+ when go out of scope, Box will automatically destructed

```
let boxed_five = Box::new(5);

enum List {
    Nil,
    Cons(i32, Box(List)),
}
```

## Generics

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

struct Point<T> {
    x: T,
    y: T,
}

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>),
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        match *self {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

```

### Generic Functions

```rust
fn foo<T, U>(x: T, y: U) {
    // ...
}
```

### Generics with Triat Bounds

```rust
fn cloning_machine<T: Clone>(t: T) -> (T, T) {
    (t.clone(), t.clone())
}

fn cloning_machine_2<T>(t: T) -> (T, T)
        where T: Clone {
    (t.clone(), t.clone())
}

fn clone_and_compare<T: Clone + Ord>(t1: T, t2: T) -> bool {
   t1.clone() > t2.clone()
}

enum Result<T, E> {
   Ok(T),
   Err(E),
}

trait PrettyPrint {
   fn format(&self) -> String;
}

impl<T: PrettyPrint, E: PrettyPrint> PrettyPrint for Result<T, E> {
   fn format(&self) -> String {
      match *self {
         Ok(t) => format!("Ok({})", t.format()),
         Err(e) => format!("Err({})", e.format()),
      }
   }
}
```

## Traits

```rust

trait PrettyPrint {
    fn format(&self) -> String;
}

struct Point {
    x: i32,
    y: i32,
}

impl PrettyPrint for Point {
    fn format(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}
```

### Trait Inheritance

+ `Eq` requires `PartialEq`, `Copy` requires `Clone`
+ Implementing the `Child` trait also requires you implement `Parent`

```rust
trait Parent {
    fn foo(&self) {
        // ...
    }
}

trait Child: Parent {
    fn bar(&self) {
        self.foo();
        // ...
    }
}
```

### Default Methods

+ trait can have default implementations for methods

```rust
trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)
    }
}

trait Eq: PartialEq<Self> {}
```

### Deriving

+ A `#[derive(...)]` attribute tells the compiler to insert a default implementation for whatever traits you tell it to

```rust
#[derive(Eq, PartialEq, Debug)]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

#### Clone

+ how to duplicate a value of type T
+ can solve ownership problems

```rust
pub trait Clone: Sized {
    fn clone(&self) -> Self;
    fn clone_from(&mut self, source: &Self) { ... }
}

// use:

#[derive(Clone)] // without this, Bar cannot derive Clone.
struct Foo {
    x: i32,
}

#[derive(Clone)]
struct Bar {
    x: Foo,
}
```

#### Copy

+ Copy denotes that a type has "copy semantics" instead of "move semantics."
+ Type must be able to copied by copying bits, Types that contain references cannot be copy

```rust
pub trait Copy: Clone { }
```

#### Debug

+ defines output for the `{:?}` formatting option

```rust
pub trait Debug {
    fn fmt(&self, &mut Formatter) -> Result;
}
```

#### Default

```rust
pub trait Default: Sized {
    fn default() -> Self;
}
```

#### Eq vs. PartialEq

```rust
pub trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool { ... }
}

pub trait Eq: PartialEq<Self> {}
```

| name | condition |
|:--- |:--- |
| PartialEq | Symmetric, Transitive |
| Eq | Symmetric, Transitive, Reflexive |

+ Symmetrics: `a == b` => `b == a`
+ Transitive: `a == b` and `b == c` => `a == c`
+ Reflexive:  `a == a`

#### Hash

```rust
pub trait Hash {
    fn hash<H: Hasher>(&self, state: &mut H);
    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)
        where Self: Sized { ... }
}
```

+ a hashable type
+ H type parameter is an abstract hash state for computing the hash
+ `Eq` and `Hash` trait should have constraint: `k1 == k2` => `hash(k1) == hash(k2)`

#### Ord vs. PartialOrd

```rust
pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {
    // Ordering is one of Less, Equal, Greater
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd<Self> {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

#### Associated Types

##### Primative solution

+ `N` and `E` don't have any meaningful association to graph
+ method `distance`  shoudl also be generic over `N` and `E`

```rust
trait Graph<N, E> {
    fn edges(&self, &N) -> Vec<E>;
    // etc
}

fn distance<N, E, G: Graph<N,E>>(graph: &G, start: &N, end: &N)
    -> u32 { /*...*/ }
```

##### Associated Types solution

```rust
trait Graph {
  type N;
  type E;

  fn edges(&self, &Self::N) -> Vec<Self::E>;
}

impl Graph for MyGraph {
  type N = MyNode;
  type E = MyEdge;

  fn edges(&self, n: &MyNode) -> Vec<MyEdge> { /*...*/ }
}
```

#### Trait Scope

+ It's possible to implement this trait on any type in rust, including types that you don't own.
+ You need to use a trait in order to access its methods on types, even if you have access to the type.
+ In order to write an impl, you need to own (i.e. have yourself defined) either the trait or the type.

#### Display

+ defind output for {} formatting option

```rust
pub trait Display {
    fn fmt(&self, &mut Formatter) -> Result<(), Error>;
}

impl Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point {}, {})", self.x, self.y)
    }
}
```

#### Addendum: Drop

+ a trait for destructable
+ never call this method yourself
+ 

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

## Closure

### Basic Syntax

```rust
let foo_v1 = |x: i32| { x * x };
let foo_v2 = |x: i32, y: i32| x * y;
let foo_v3 = |x: i32| {
    // Very Important Arithmetic
    let y = x * 2;
    let z = 4 + y;
    x + y + z
};
let foo_v4 = |x: i32| if x == 0 { 0 } else { 1 };
```

### Closure Environment

> 待总结

### Closure Traits

```rust
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call"
      fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call"
      fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    type Output;

    extern "rust-call"
      fn call_once(self, args: Args) -> Self::Output;
}
```

### Closure as Arguments

```rust
// self = Vec<A>
fn map<A, B, F>(self, f: F) -> Vec<B>
    where F: FnMut(A) -> B;
```

### Closure as Return values

```rust
// error!
fn i_need_some_closure() -> (Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// reviewed but error
fn i_need_some_closure_by_reference() -> &(Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// final
fn box_up_your_closure_and_move_out() -> Box<Fn(i32) -> i32> {
    let local = 2;
    Box::new(move |x| x * local)
}
```

## Std Lib

### String

+ A String and an &str may be concatenated with +, Concatenating two Strings requires coercing one to &str.

concersion case:

```rust
use std::net::TcpStream;

TcpStream::connect("192.168.0.1:3000"); // &str
let addr = "192.168.0.1:3000".to_string();
TcpStream::connect(&*addr);
```
This doesn't automatically coerce because TcpStream doesn't take an argument of type &str, but a Trait bounded type:
`TcpStream::connect<A: ToSocketAddr>(addr: A)`

```rust
trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

+ Since String implements `Deref<Target=str>`, so values of &String will automatically be dereferenced to &str when possible.
+ `Vec`、`&str` 可以方便的转换为 String
+  Copy a `String` is expensive;

### `Option<T>`

```rust
enum Option<T> {
    None,
    Some(T),
}

fn unwrap<T>(&self) -> T;
fn map<U, F>(self, f: F) -> Option<U> { ... };
fn and_then<U, F>(self, f: F) -> Option<U>
      where F: FnOnce(T) -> Option<U> { ... };
fn unwrap_or<T>(&self, default: T) -> T { ... };
fn unwrap_or_else<T>(&self, f: F) -> T
            where F: FnOnce() -> T { ... };

fn is_some(&self) -> bool { ... };
fn is_none(&self) -> bool { ... };
fn map_or<U, F>(self, default: U, f: F) -> U
    where F: FnOnce(T) -> U { ... };
fn map_or_else<U, D, F>(self, default: D, f: F) -> U
    where D: FnOnce() -> U, F: FnOnce(T) -> U { ... };
fn ok_or(self, err: E) -> Result<T, E> { ... };
fn ok_or_else(self, default: F) -> Result<T, E>
    where F: FnOnce() -> E { ... };
fn and<U>(self, optb: Option<U>) -> Option<U> { ... };
fn or(self, optb: Option<T>) -> Option<T> { ... };
```

### `Result<T, E>`

```rust
enum Result<T, E> {
    Ok(T),
    Err(E)
}
```

+ Unlike Option, you should always consume `Result`, such as `unwrap` or `expect` or handle `Ok` / `Err`。

### Collections

+ `Vec<T>`
+ `VecDeque<T>`
+ `LinkedList<T>`
+ `HashMap<K, V>`
    - `K: Hash + Eq`
+ `BTreeMap<K, V>`
    - `K: Ord`
+ `BinaryHeap<T>`

#### `Iterator`

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;

    // More fields omitted
}
```

+ three types of iteration:
    - `into_iter()` yield `T`
    - `iter()` yielding `&T`
    - `iter_mut()` yielding `&mut T`

##### `collect`

```rust
fn collect<B>(self) -> B where B: FromIterator<Self::Item>
```

+ `collect()` rolls a lazy iterator back into an actual collection。
+  target collection must define the `FromIterator` trait for the `Item` inside the Iterator.
+ Sometimes needs a type hint to properly compile.

##### `fold`

```rust
fn fold<B, F>(self, init: B, f: F) -> B
    where F: FnMut(B, Self::Item) -> B;
```

##### `filter`

```rust
fn filter<P>(self, predicate: P) -> Filter<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```
+ `filter` returns a `Filter<Self, P>`

##### `find` and `position`

```rust
fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
    where P: FnMut(Self::Item) -> bool;

fn position<P>(&mut self, predicate: P) -> Option<usize>
    where P: FnMut(Self::Item) -> bool;
```

##### `skip`

```rust
fn skip(self, n: usize) -> Skip<Self>;
```

##### `zip`

```rust
fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>
    where U: IntoIterator;
```

##### `any` and `all`

```rust
fn any<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;

fn all<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;
```

##### `enumerate`

+ use enumerate!
+ (index, value)

```rust
fn enumerate(self) -> Enumerate<Self>;
```

##### Iterator Adapters
+ Adapters operate on an iterator and return a new iterator
+ offen lazy
+ use iterator consumer on an adapter or use it in a for loop

##### `map`

```rust
fn map<B, F>(self, f: F) -> Map<Self, F>
    where F: FnMut(Self::Item) -> B;
```

##### `take` and `take_while`

```rust
fn take(self, n: usize) -> Take<Self>;

fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```

##### `cloned`

```rust
fn cloned<'a, T>(self) -> Cloned<Self>
    where T: 'a + Clone, Self: Iterator<Item=&'a T>;
```

+ Create an iteratir which calls clone on all of its elements.
+ equal to `vs.iter().map(|v| v.clone())`
+ Using: when you have an iterator over `&T`, but need one over `T`

## Pointer Types

+ `&T` and `&mut T`
+ `Box<T>`
+ `std:rc::Rc<T>` `Rc::downgrade()`
+ `std::rc::Weak<T>` `weak.upgrade() -> Option<Rc<T>>`
+ `Cell<T>` 
    - Just providing interior mutability of `Copy` types.
    - With `get()` and `set()` never mutate `T`, just replace it.    
+ `RefCell<T>` 
    - Dynamic borrow checking rules, maybe panic at runtime.
    - `borrow()` and `borrow_mut()`
    - not thread safe, maybe panic at runtime.
    - A common paradigm is putting a `RefCell` inside an `Rc` allow shared mutability
+ `std::cell::Ref<T>` and `RefMut<T>`
    - when you invoke `borrow()` on a `RefCell<T>` actually get `Ref<T>` not `&T`
    - while `borrow_mut()` gives you a `RefMut<T>`
+ `*const T` and `*mut T`
    - no ownership, no lifetime, C-like raw pointers
    - require `unsafe` before dereference

```rust
let c = Cell::new(10);
c.set(2);
println!("{}", c.get());
```

## Misc Syntax

+ `const` must annotate type, and is `live` for the duration of the program, may hava multi references.
+ `static` must annotate type, with fixed memory address, unsafe to mutate, with `static` lifetime.

```rust
const PI: f32 = 3.14159;
static PI: f32 = 3.14159;
```

## Modules and Crates

+ Everything in rust is module-scoped: if it's not pub, it's only accessible from within the same module.

### 1. Modules can be defined within one file

```rust
mod english {
    pub mod greetings {
    }
    pub mod farewells {
    }
}

mod japanese {
    pub mod greetings {
    }
    pub mod farewells {
    }
}
```

### 2. Modules can be defined as files instead

+ `lib.rs`
```rust
mod english;
```
+ `english.rs`
```rust
pub mod greetings { /* .... */ }
```

### 3. Modules can be defined as directories

+ `lib.rs`
```rust
mod english;
```

+ `english/`
    - `mod.rs`
        ```rust
        pub mod greetings;
        ```
    - `greetings.rs`
        ```rust
        /* .... */
        ```

### 4 Namespacing

```rust
mod one {
    mod two {
        fn foo() { ... }
    }
    fn bar() {
        two::foo();
    }
}

mod three {
    mod four {
        pub fn foo() { ... }
    }

    fn bar() {
        ::one::two::foo();
    }
}
```

### 5 `use` in Modules
+ `use` directives are absolute by default
+ can be relative to the current module
+ `pub use` can be used to re-export other items

```rust
use english::greetings;
use self::greetings;
use super::japanese;

#[cfg(english)]
pub use english::*;

#[cfg(japanese)]
pub use japanese::*;
```

## Crate

```rust
extern crate rand;

use rand::Rng;
```

```yaml
[dependencies]
myfoo = { git = "https://github.com/me/foo-rs" }
mybar = { path = "../rust-bar" }

// or
[dependencies]
git = "https://github.com/me/foo-rs"
```

## Cargo

+ cargo allows both: `/src/lib.rs/` and `/src/main.rs`
+ cargo will also build: `/src/bin/*.rs` as executables.
+ Examples in `/examples/*.rs` will build by `cargo test`, can be called with `cargo run --example foo`
+ integrate tests in: `/tests/*.rs`
+ benchmarks in `/benches/*.rs`


### Features

+ build time use: `cargo build --features using-html9`

```yaml
[package]
name = "myfacebumblr"

[features]
# Enable default dependencies: require web-vortal *feature*
default = ["web-vortal"]

# Extra feature; now we can use #[cfg(feature = "web-vortal")]
web-vortal = []

# Also require h9rbs-js *crate* with its commodore64 feature.
using-html9 = ["h9rbs-js/commodore64"]

[dependencies]
# Optional dependency can be enabled by either:
# (a) feature dependencies or (b) extern crate h9rbs_js.
h9rbs-js = { optional = "true" }
```

### build scripts

script write by rust can provide more cargo can do.

```rust
[package]
build = "build.rs"
```

### Attributes

+ `#[test]`
+ `#![test]`
+ `#![no_std]`
+ `#[inline(always)]`
+ `#[allow(missing_docs)]`
+ `#![crate_type = "lib"]`
+ `#![feature(box_syntax)]`
+ `#[cfg(target_os = "linux")]`


## [Rust Code Stype](https://github.com/cis198-2016s/slides/blob/gh-pages/07/content.md#rust-code-style-1)

+ `CamelCase`:              types, traits.
+ `lowerCamelCase`:         not used.
+ `snake_case`:             crates, modules, functions, methods, variables.
+ `SCREAMING_SNAKE_CASE`:   static variables and constants.
+ `T`                       (single capital letter): type parameters.
+ `'a`                      (tick + short lowercase name): lifetime parameters.

+ Constructor and conversions should be worded:
    - `new`, `new_with_stuff`: constructors.
    - `from_foo`: conversion constructors.
    - `as_foo`: free non-consuming conversion.
    - `to_foo`: expensive non-consuming conversion.
    - `into_foo`: consuming conversion.

## `format!`

+ `{<num>:<triat>}`
    - `<num>` the index of the argument list
    - `<trait>` use of trait

| spec | trait |
|:---  |:--- |
| `{}` | Display |
| `{:x}` | LowerHex |
| `{:b}` | Binary |
| `{:?}` | Debug |
| `{:X}` | UpperHex |
| `{:e}` | LowerExp |
| `{:o}` | Octal |
| `{:p}` | Pointer |
| `{:E}` | UpperExp |

+ `{:04}` -> `0010`: padding
+ `'{:^4}'` -> `' 10 '`: alignment (centering)
+ `#` indicates an "alternate" print format:
+ `{:#X}` -> `0xA`: including 0x
+ `{:#?}`: Pretty-prints objects

## Operators

+ Unary operators: `!` `-` `*` `&` `&mut`
+ `as` casting
+ `*` `/` `%` multiplicative arithmetic
+ `+` `-` additive arithmetic
+ `<<` `>>` shift arithmetic
+ `&` bitwise and
+ `^` bitwise xor
+ `|` bitwise or
+ `==` `!=` `<` `>` `<=` `>=` logical comparison
+ `&&` logical and
+ `||` logical or
+ `=` `..` assignment and ranges

### trait for Operators:
+ Rust defines these - surprise! - using traits, in `std::ops`.
    - `Neg`, `Not`, `Deref`, `DerefMut`
    - `Mul`, `Div`, `Mod`
    - `Add`, `Sub`
    - `Shl`, `Shr`
    - `BitAnd`
    - `BitXor`
    - `BitOr`
    - `Eq`, `PartialEq`, `Ord`, `PartialOrd`
    - `And`
    - `Or`
+ Also: `Fn`, `FnMut`, `FnOnce`, `Index`, `IndexMut`, `Drop`

+ Casting (as) cannot be overloaded. we use `From` an `Into`
    - `trait From<T> { fn from(T) -> Self; }`  called: `Y::from(x)`
    - `trait Into<T> { fn into(self) -> T; }`  called: `x.into()`

```rust
struct A(Vec<i32>);

impl From<Vec<i32>> for A {
    fn from(v: Vec<i32>) -> Self {
        A(v)
    }
}

/// `From` is impossible， so only `Into` is allowed.
impl From<A> for Vec<i32> { // error: private type A in
    fn from(a: A) -> Self { // exported type signature.
        let A(v) = a; v     // (This impl is exported because
    }                       // both the trait (From) and the type
}                           // (Vec) are visible from outside.)

impl Into<Vec<i32>> for A {
    fn into(self) -> Vec<i32> {
        let A(v) = self; v
    }
}
```

### Making Reference

+ `Borrow` / `BorrowMut`: a trait for borrowing data [doc](https://doc.rust-lang.org/std/borrow/trait.Borrow.html)
```rust
trait Borrow<Borrowed> { fn borrow(&self) -> Borrowed; }
```

+ `AsRef` / `AsMut` a cheap, reference-to-reference conversion [doc](https://doc.rust-lang.org/std/convert/trait.AsRef.html)
```rust
trait AsRef<T> { fn as_ref(&self) => &T; }
```

+ If you are implementing Borrow and both Self and Borrowed implement Hash, Eq, and/or Ord, they must produce the same result.
+ Borrow has a blanket implementation: `impl<T> Borrow<T> for T`: you can always convert `T` to `&T`.
+ AsRef actually has its own blanket implementation:
    - `impl<'a, T, U> AsRef<U> for &'a T where T: AsRef<U>`
    - For all `T`, if `T` implements `AsRef`, `&T` also implements `AsRef`

## I/O

### Trait

```rust
pub trait Read {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
    // other methods implemented in terms of read
}

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    // other methods implemented in terms of write() and flash()
}
```

+ Standard IO traits implemented for a variety of types:
    - `File`, `TcpStream`, `Vec<T>`, `&[u8]`
+ return `std::io::Result` not the `std::Result`
    - `type Result<T> = Result<T, std::io::Error>`

### `std::io::Read`

```rust
use std::io;
use std::io::prelude;
use std::fs::File;

let mut f = try!(File::open("foo.txt"));
let mut buffer = [0; 10];

// read up to 10 bytes
try!(f.read(&mut buffer));
```

+ `buffer` is an array, so the max length to read is encoded into the type
+ `read` returns the number of bytes `Ok(n)` read or an Err

```rust
fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
// read to the end of the Read object
fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize>;
// reads to the end of the Read object to a string
fn read_to_string(&mut self, buf: &mut String) -> Result<usize>;
// reads exactly the length of the buffer, or throws an error
fn read_exact(&mut self, buf: &mut [u8]) -> Result<()>;
```

### Reading Iterators

```rust
fn bytes(self) -> Bytes<Self> where Self:Sized;
fn chars(self) -> Bytes<Self> where Self:Sized;
```
+ associated `Item` is `Result<u8>`
    - `next()` return `Option<Result<u8>>`
    - `EOF` corresponds to `None`
+ **Adaptors**

```rust
fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized;

fn take<R: Read>(self, limit: u64) -> Take<Self> where Self: Sized;
```

### `std::io::write`

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    /// Attempts to write entire buffer into self.
    fn write_all(&mut self, buf: &[u8]) -> Result<()> { ... }

    /// Writes a formatted string into self.
    /// Don't call this directly, use `write!` instead.
    fn write_fmt(&mut self, fmt: Arguments) -> Result<()> { ... }

    /// Borrows self by mutable reference.
    fn by_ref(&mut self) -> &mut Self where Self: Sized { ... }
}

// example
let mut buffer = trr!(File::create("foo.txt"));
try!(buffer.write("Hello, Ferris"));
```

#### 1 `write!`
```rust
let mut buf = try!(fILE::create("foo.txt"));
write!(buf, "Hello {}!", "Ferris").unwrap();
```

#### 2 `BufReader`
```rust
fn new(inner: R) -> BufReader<R>;
fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> { ... };
fn read_line(&mut self, buf: &mut String) -> Result<usize> { ... };
fn split(self, byte: u8) -> Split<Self> where Self: Sized { ... };
fn lines(self) -> Lines<Self> where Self: Sized{ ... };

pub trait BufRead: Read {
    fn fill_buf(&mut self) -> Result<&[u8]>;
    fn consume(&mut self, amt: usize);
}

// example
let mut f = try!(File::open("foo.txt"));
let buffered_reader = BufReader::new(f);
```

#### 3 `BufWriter`

Just caches all wites until the BUfWriter goes out of scope, then writes them all at once.

#### 4 `StdIn`

```rust
let mut buffer = String::new();
try!(io::stdin().read_line(&mut buffer));
```

no need for BufReader.

#### 5 `StdInLock`
+ A "lock" on standard input mean only that current instance of `StdIn` can read from the terminal.
+ All `read` methods call `self.lock()` internally.
+ A `StdInLock` implements `Read` and `BufRead`

```rust
let lock: io::StdInLock = io::stdin().lock();
```

 #### 6 `StdOut`

 + implements `Write`
 + prefer use `print!` or `println!`

 #### 7 Special IO Structs

+ `repeat(byte: u8)`: A reader which will infinitely yield the specified byte. It will always fill the provided buffer.
+ `sink()`: "A writer which will move data into the void."
+ `empty()`: A reader which will always return Ok(0).
+ `copy(reader: &mut R, writer: &mut W) -> Result<u64>` copies all bytes from the reader into the writer.

### `Serde`

```rust
#![feature(custom_derive, plugin)]
#![plugin(serde_macros)]

extern crate serde;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
pub struct X { a: i32, b: String }

fn main() {
    let object = X { a: 6, b: String::from("half dozen") };
    let encoded = serde_json::to_string(&object).unwrap();
    // ==> the string {"a":6,"b":"half dozen"}
    let decoded: X = serde_json::from_str(&encoded).unwrap();
}
```

## Network

### 1 Socket

+ 一种基本的，通过网络发送和接受数据的方式，
    > IPC sockets 是 Unix 中的东西，易混淆
+ Layers socket-programming providers:
    - OS: System calls
    - pl: language special std lib
    - Higher-level networking libraries handling a specific protocol. such as HTTP

#### 1 Datagram Sockets (UDP)

+ User Datagram Protocol sockets
+ Stateless
+ at least once delivery, no guaranteed, no order, maybe receive more than once.
+ `send_to(addr)` and `recv_from()`

example code:

```rust
// Try to bind a UDP socket
let mut socket = try!(UdpSocket::bind("127.0.0.1:34254"));

// Try to receive data from the socket we've bound
let mut buf = [0; 10];
let (amt, src) = try!(socket.recv_from(&mut buf));

// Send a reply to the socket we just received data from
let buf = &mut buf[..amt];
buf.reverse();
try!(socket.send_to(buf, &src));

// Close the socket
drop(socket);
```

#### 2 Stream Sockets (TCP)

+ Transmission Control Protocol sockets
+ Stateful, need connection
+ inorder, exactly once, via packet sequence numbers.
+ package has ack
+ `listen` `streams`

##### `std::net::TcpStream`

client example code:

```rust
// Create a TCP connection
let mut stream = TcpStream::connect("127.0.0.1:34254").unwrap();

// Uses std::io::{Read, Write}

// Try to write a byte to the stream
let write_result = stream.write(&[1]);

// Read from the stream into buf
let mut buf = [0; 128];
let read_result = stream.read(&mut buf);

// ...
// Socket gets automatically closed when it goes out of scope

```

server example code:

```rust
let listener = TcpListener::bind("127.0.0.1:80").unwrap();

fn handle_client(stream: TcpStream) { /* ... */  }

// Accept connections and process them,
// spawning a new thread for each one.
for stream in listener.incoming() {
    match stream {
        Ok(stream) => {
            thread::spawn(move|| {
                // connection succeeded
                handle_client(stream)
            });
        }
        Err(e) => { /* connection failed */ }
    }
}

// close the socket server
drop(listener);
```

#### 3 `SocketAddr`
+ A socket address representation.
+ May be either IPv4 or IPv6.
+ Easily created using...

```rust
pub trait ToSocketAddrs {
    type Iter: Iterator<Item=SocketAddr>;
    fn to_socket_addrs(&self) -> Result<Self::Iter>;
}
```

### HTTP

> hyper 和课程中的表述已经发生了较大的变化，回头总结。

## Concurrent

### why concurrency hard?

+ `Sharing data`
+ `Data races`
+ `Synchronization`
+ `Deadlock`

> Deadlock: mutual exclusion, resource holding, no preemption, circular waiting

### rust thread

+ `std::thread`
+ `std::thread::JoinHandler` cannot be cloned
+ `panic!` Thread panic is unrecoverable from within the panicking thread
    - Only the thread that panics will crash
    - The thread will unwind its stack, cleaning up resources
    - The message passed to `panic` can be read from other thread!
+ get thread object: `handle.thread()`, `thread::curent()`
```rust
use std::thread;

let handle = thread::spawn(|| {
    thread::park();
    println!("hello world!");
});

println!("good night");
handle.thread().unpark();
println!("{:?}", handle.join().unwrap());
```

### `Send` `Sync`

+ Rust type system includes traits for enforcing certain concurrency guarantees.
+ `Send` a type can be safely transferred between threads.
    - have its ownership transferd across threads.
    - Noimplementing `Send` enforces that a type may not leave its original thread
+ `Sync` a type can be safely shared between threads
    - can't introduce memory unsafety when uded across multiple threads
    - all primitive types are `Sync`; all aggregate types containing only that are `Sync` are also Sync.
        -  `T` is thread safe => `&T` and `&mut T`  is thread safe.
+ Both `Send` and `Sync` are marker traits, which don't implements any methods
+ rust safety checks is not guaranteed. Implementation should uphold the traits guarentees.
+ `Send` is auto- derived for all types whose member are all `Send`.
+ `Sync` is auto-derived for all types whose members are all `Sync`
    - remove an automatic derivation


```rust
impl !Send for Foo {}
impl !Sync for Foo {}
```

### Share Thread State

** error1 **
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}

// error: capture of moved value: `data`
//        data[i] += 1;
//        ^~~~
```

> why error? maybe have multi owners!

### `std::sync::Arc<T>` Atomic Reference-Counted pointer

+ like `Rc` but thread safety
+ also has a corresponding `Weak` Variant

** error2 **

```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone(); // Increment `data`'s ref count
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
```

+ like `Rc` `Arc has no interior mutability

### `Mutex`

+ short for Mutual Exclusion
+ ensure that a value can only be accessed by one thread at a time.
+ When a value is wrappted in a `Mutex`, you must call lock on the Mutex to get access to the value inside. This method returns a `LockResult`
+ If a thread acquires a mutex lock and then panics, the mutex is considered poisoned, as the lock was never released.
+ `lock()` return a `LockResult`
    - `Ok(MutexGuard)` the mutex was not poisoned and maybe used
    - `Err(PoisonError<MutexGuard>)`
+ a poisoned mutex can be access by calling `into_inner`, `get_ref`, `get_mut`


```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone(); // Increment `data`'s ref count
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
    // dont known when all of them finished!
}
```

### `std::sync::mpsc`

+ Multi-Producer, Single-Consumer
+ three main types:
    - `Sender`
    - `SyncSender`
    - `Receiver`
+ `Sender` or `SyncSender` can send data to `Receiver`
+ Sender types may be cloned and given-to multi threadd to create multiple producers

```rust
use std::thread;
use std::sync::mpsc::channel;

fn main() {
    let (tx, rx) = channel();
    for i in 0..10 {
        let tx = tx.clone();
        thread::spawn(move|| {
            tx.send(i).unwrap();
        });
    }
    drop(tx);

    let mut acc = 0;
    while let Ok(i) = rx.recv() {
        acc += i;
    }
    assert_eq!(acc, 45);
}
```
#### ASync

+ `(Sender<T>, Receiver<T>) = channel<T>()`
+ `Sender` is an asynchronous channel
+ Sending data across the channel is never block the sending thread, `Sender` has a conceptually-infinite buffer

#### Sync
+ `(SyncSender<T>, Receiver<T>) = sync_channel<T>()`
+ `SyncSender` is synchronized, block when you send a message, until the buffer space available.

### `std::sync::RwLock<T>`
+ a read write lock
+ like `Mutex` but separate modes for reading and writing access
+ allow data access to many readers or one writer
+ inner `T` must be `Send + Sync`
+ Poisoning only occurs if a writer panics
+ Useful if you have many threads requesting reads and few requesting writes
+ `RwLock` only works on `Sync` types
+ `RefCell`, also encoding single-write-multiple-read idea

### `std::sync::Barrier`

### `std::sync::Condvar`

### `std::sync::Once`

## Rust Atomics

+ atomic: apears to occur "instantly" from the program's perspective
+ rust's atomic primitives define this behavior at the type level
+ Four kinds: `AtomicUsize`, `Isize`, `Bool`, `Ptr`
+ use same ordering as `LLVM`， and the same atomic model as C11

## Rayon

+ Two primary features
    - Parallel iterators: take iterator chains and execute them in parallel
    - `rayon::join` converts recursive divide and conquer iterators to execute in parallel

### Parallel Iterators

```rust
// Increment all values in a slice
use rayon::prelude::*;
fn increment_all(input: &mut [i32]) {
    input.par_iter_mut()
         .for_each(|p| *p += 1);
}
```

### Recursive Divide and Conquer
+ Recursive divide-and-conquer problems can be parallelized using Rayon's `join` method
+ Parallel iterators are built on this method,and par_iter() abstracts over it
+ 

> 补充更多 Rayon 的内容

## futures and tokio

> 补充更多内容

## Unsafe Rust

### why unsafe
rust 的安全性检查相对是比较保守的使得很多安全的代码无法通过 rust 的安全性检查。
unsafe 特性提供了一种绕过 rust 的编译器安全性检查的方法，使得我们可以：
+ 和其他的语言进行交互， 比如 `C` 
+ 编写一些 `std` 库不提供的底层方法
+ 使用一些特殊的 ownership 交互

### 基本用法
+ unsafe code 应当使用 `unsafe` 关键字包装
+ 一个函数可以定义为 `unsafe` 的
+ 

## FFI

## Macros

