# Web Component

## 1 [diesel](https://github.com/diesel-rs/diesel)

[postgres 数据库命令参考](https://mozillazg.github.io/2014/06/hello-postgresql.html)
Diesel 由两部分组成，一部分是在 cargo 中指定，需要安装的依赖包，另一部分则是一些 cli 工具。

### 1. 依赖包如下：

```toml
[dependencies]
diesel = { version = "0.11.0", features = ["postgres"] }
diesel_codegen = { version = "0.11.0", features = ["postgres"] }
dotenv = "0.8.0"

# 使用 sqlite
diesel = { git = "https://github.com/diesel-rs/diesel", features = ["sqlite", "large-tables"] }
diesel_codegen = { git = "https://github.com/diesel-rs/diesel", features = ["sqlite"] }
r2d2 = "0.7.2"
r2d2-diesel = { git = "https://github.com/king6cong/r2d2-diesel" }
libsqlite3-sys = { version = "=0.8.0", features = ["bundled"] }
```

### 2. 安装 cli 工具：

```bash
cargo install diesel_cli
```

### 3. 通过设定环境变量指定 postgres 数据库的位置:

```bash
echo DATABASE_URL=postgres://username:password@localhost/diesel_demo > .env
```

### 4. cli 初始化数据库

```bash
diesel setup
```

如果没有数据库，则创建，并创建一个空的 migrations 文件来管理我们的 schema。
创建一个具体的 migration 如下：

```bash
diesel migration generate create_posts
```

这会创建两个文件如下：

```bash
Creating migrations/20160815133237_create_posts/up.sql
Creating migrations/20160815133237_create_posts/down.sql
```

编写用于 migrate 的 SQL 语句如下：

UP SQL:

```sql
CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  title VARCHAR NOT NULL,
  body TEXT NOT NULL,
  published BOOLEAN NOT NULL DEFAULT 'f'
)
```

DOWN sql

```sql
DROP TABLE posts
```

应用 migrate 实现如下：

```bash
diesel migration run
```

使用正确的 `down.sql` 可以实现下面的 redoing 如下：

```bash
diesel migration redo
```

### 5. 创建数据库的连接

示例代码，创建一个数据库连接池(使用 sqlite)：

```rust
extern crate diesel;
extern crate diesel_codegen;
extern crate r2d2;
extern crate r2d2_diesel;
extern crate dotenv;

use std::path::Path;
use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;
use r2d2_diesel::ConnectionManager;
use dotenv::dotenv;

// 数据库的路径
let path: &str = "xxx\addd\addd";
let db_name: &str = "xxx.db";
let database_url = Path::new(&path).join(&name).to_str().ok_or(Error::from("failed to get url to db!"));

// 连接池的配置和管理
let config = r2d2::Config::default();
let manager = ConnectionManager::<SqliteConnection>::mew(database_url);
let pool = r2d2::Pool::new(config, manager).expect("failed to create pool");

// ??? 待明确原因
embed_migrations!();
embedded_migrations::run(&*pool.get().unwrap()).unwrap();

// 从数据库中获得一个数据库的连接
let conn = pool.get().unwrap();
```

## 2 [ws-rs](https://github.com/housleyjk/ws-rs)

### 使用 ws 的开发版本

```yml
[dependencies]
ws = { version = "*", git = "https://github.com/housleyjk/ws-rs"}
```

### simple use

+ Server

```rust
extern crate ws;

use ws::listen;

fn main() {
  listen("127.0.0.1:3012", |out| {  // 也可以接受一个 Factory
      move |msg| {
         out.send(msg)
      }
  }).unwrap()
}
```

+ client

```rust
extern crate ws;

use ws::{connect, CloseCode};

fn main() {
  connect("ws://127.0.0.1:3012", |out| {
      out.send("Hello WebSocket").unwrap();

      move |msg| {
          println!("Got message: {}", msg);
          out.close(CloseCode::Normal)
      }
  }).unwrap()
}
```

上面会封装为一个 mio 的 EventLoop，创建并在当前线程中运行一个 WebSocket。这些都是阻塞的函数，只有
启动的 websocket 断开后才会返回。

## 3 [iron](http://ironframework.io/doc/iron/)

+ [router](https://github.com/SergioBenitez/Rocket)

## 4 [tokio](https://tokio.rs/)

+ `tokio-proto` 构建 servers 和 clients 的简单接口
+ `tokio-core` 构建自定义的，低层次的异步代码
+ `futures` 提供了 `futures`、`streams`、`sinks` 的概念

### 1 [future](https://tokio.rs/docs/getting-started/futures/)

future 的使用场景：

1. 数据库查询
1. 一个 rpc 的远程调用
1. 超时
1. 一个长时间运行的 CPU 密集任务
1. 从 socket 读取一些字节数据

#### 1 简单的例子

#### 2 combine

+ `then`:
+ `select`: 组合两个相同类型的 futures，并根据完成时间进行 race

> 要进一步补充相关内容

## 5 [error-chain]

更好地利用 rust 的错误处理特征，定义自己的错误，并将其他错误转换过来。参考资料：

+ [starting](http://brson.github.io/2016/11/30/starting-with-error-chain)
+ [doc](https://docs.rs/error-chain/0.10.0/error_chain/)

### 概述

#### why

+ error-chain is easy to configure. Handle errors robustly with minimal effort.
+ Basic error handling requires no maintenance of custom error types nor the From conversions that make ? work.
+ error-chain scales from simple error handling strategies to more rigorous. Return formatted strings for simple errors, only introducing error variants and their strong typing as needed for advanced error recovery.
+ error-chain makes it trivial to correctly manage the cause of the errors generated by your own code. This is the "chaining" in "error-chain".

#### 基本原则

+ 所有的错误都不应该被丢弃，而是 `chain` error。提供了 `chain_err` 方法。
+ 引入的 error 是琐碎的，简单的错误可以通过一个字符串表示。
+ 使用 pattern match 来处理错误。
+ 错误的转换是一致和自动的，`From` 转换行为不应该是特定的。
+ Errors 都实现了 Send
+ Errors 可以携带 backtraces

和类似的库 [error-type](https://github.com/DanielKeep/rust-error-type) 和 [quick-error](http://tailhook.github.io/quick-error/quick_error/index.html) 使用了类似的机理，`error-chain` 也使用了 Cargo 提供的方法。error_chain! 宏定义了完成一个特殊的错误处理策略所需的模板。

特点

1. 没有定义 Error enum，而是定义了 `ErrorKind(fn description, fn display)`，一个透明、boxed、可选的 `std::error::Error + Send + 'static` 对象（其中定义了 `cause`，并在 `error_chain` 中定义了 links，以及一个 Backtrace。
1. 定义了 `ResultExt`，其 `chain_err` 方法可以将 `std::error::Error + Send + 'static` 类型进行 boxed 并保存到 error chain 中。（作为新 concrete error 的 inside)
1. 他提供了自动的 `From` 方法将在 `error_chain!` 中定义的其他错误类型保留 type 信息，将他们灵活地组合起来。

`starting` 中给出了一个模板。

1. 在 Cargo.toml 中添加 `error-chain = "0.10.0"`
1. 实例代码

```rust
mod other_error {
    error_chain! {}
}

error_chain! {
    // The type defined for this error. These are the conventional
    // and recommended names, but they can be arbitrarily chosen.
    //
    // It is also possible to leave this section out entirely, or
    // leave it empty, and these names will be used automatically.
    types {
        Error, ErrorKind, ResultExt, Result;
    }

    // Without the `Result` wrapper:
    //
    // types {
    //     Error, ErrorKind, ResultExt;
    // }

    // Automatic conversions between this error chain and other
    // error chains. In this case, it will e.g. generate an
    // `ErrorKind` variant called `Another` which in turn contains
    // the `other_error::ErrorKind`, with conversions from
    // `other_error::Error`.
    //
    // Optionally, some attributes can be added to a variant.
    //
    // This section can be empty.
    links {
        Another(other_error::Error, other_error::ErrorKind) #[cfg(unix)];
    }

    // Automatic conversions between this error chain and other
    // error types not defined by the `error_chain!`. These will be
    // wrapped in a new error with, in the first case, the
    // `ErrorKind::Fmt` variant. The description and cause will
    // forward to the description and cause of the original error.
    //
    // Optionally, some attributes can be added to a variant.
    //
    // This section can be empty.
    foreign_links {
        Fmt(::std::fmt::Error);
        Io(::std::io::Error) #[cfg(unix)];
    }

    // Define additional `ErrorKind` variants. The syntax here is
    // the same as `quick_error!`, but the `from()` and `cause()`
    // syntax is not supported.
    errors {
        InvalidToolchainName(t: String) {
            description("invalid toolchain name")
            display("invalid toolchain name: '{}'", t)
        }
    }
}
```

## 6 protobuf

```bash
cargo install protobuf
```

## 7 hyper

+ [Guide Page](https://hyper.rs/guides/)

`Body` 实现了 `Stream` trait，当收到数据时返回一系列的 `Chunk`， `Chunk` 只是一些 bytes 的表示。

```rust
#[derive(Debug, Clone)]
pub struct PostData {
    pub url: String,
    pub data: Vec<u8>,
    pub headers: Option<Headers>,
}

impl PostData {
    pub fn new(url: &str, data: Vec<u8>, headers: Option<Headers>) -> Self {
        PostData {
            url: url.to_owned(),
            data: data,
            headers: headers,
        }
    }
}

pub fn post_req(post_data: &PostData) -> Result<Request> {
    let url = post_data.url.parse::<hyper::Uri>()?;
    let mut req = Request::new(Post, url);
    {
        let headers = req.headers_mut();

        // 从全局配置中获得 token
        let access_token = CONFIG
            .read_lock()
            .access_token
            .clone()
            .unwrap_or("".to_owned());
        let mut cookie = Cookie::new();
        cookie.append("session", access_token);

        // 设置 http 头文件
        headers.set(cookie);
        headers.set(ContentType(Mime::from_str("application/json").unwrap()));

        // post_data 增加了 header 内容
        match post_data.headers {
            Some(ref passed_headers) => {
                headers.extend(passed_headers.iter());
            }
            None => {}
        }
    }
    req.set_body(post_data.data.clone());
    Ok(req)
}

pub fn get_client(handle: &Handle) -> hyper::Client<hyper_tls::HttpsConnector<HttpConnector>> {
    let client = hyper::Client::configure()
        .connector((hyper_tls::HttpsConnector::new(4, handle)).unwrap())
        .build(handle);

    client
}

pub fn fetch_async(req: Request,
                    client: &hyper::Client<hyper_tls::HttpsConnector<HttpConnector>>)
                    -> impl Future<Item = CallbackData, Error = CallbackData> {
    let timer = Timer::default();
    let timeout = timer
        .sleep(Duration::from_millis(TIMEOUT))
        .or_else(|e| {
                      warn!("timeout error");
                      Err(CallbackData::new(CallbackCode::TimerError(e), None, vec![], None))
                  })
        .and_then(|_| {
                      warn!("request timeout");
                      Err(CallbackData::new(CallbackCode::Timeout,
                                            None,
                                            "timeout".to_string().into_bytes(),
                                            None))
                  });
    trace!("start process uri: {}", req.uri());

    let now = Instant::now();
    let work = client
        .request(req)
        .and_then(|res| {
            let status = res.status();
            let headers = res.headers().clone();
            trace!("Response: {}", status);
            res.body()
                .fold((status, headers, Vec::new()),
                      |(status, headers, mut acc), chunk| {
                          acc.extend_from_slice(chunk.as_ref());
                          Ok::<_, hyper::Error>((status, headers, acc))
                      })
        })
        .and_then(move |(status, headers, body)| {
            let pb_status = match Fetch::get_pb_status(status, &body) {
                Ok(pb_status) => pb_status,
                Err(err) => {
                    warn!("get pb status failed: err= {:?}", err);
                    None
                }
            };
            info!("fetch cost: {:?}", now.elapsed());

            Ok(CallbackData::new(CallbackCode::Normal(status), Some(headers), body, pb_status))
        })
        .or_else(|e| {
                      trace!("HyperError: {:?}", e);
                      Err(CallbackData::new(CallbackCode::HyperError(e), None, vec![], None))
                  });

    let work = work.select(timeout)
        .and_then(|(callback_data, _)| Ok(callback_data))
        .or_else(|(e, _)| {
                      info!("fetch_async_error: {:?}", e);
                      Err(e)
                  });

      work
}
```

> 要进一步补充相关内容

## 8 log

+ [log facade document](https://doc.rust-lang.org/log/log/index.html)
+ [env_logger](https://docs.rs/env_logger/*/env_logger/)

## 9 lazy_static 和配置文件的实现

```rust
#[macro_use]
extern crate lazy_static;

use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};

#[derive(Default, Debug)]
pub struct Config {
    pub storage_path: String,
    pub access_token: Option<String>,
    pub device_id: Option<String>,
    pub user_id: Option<i64>,
    pub inited: bool,
    pub net_type: Option<i32>,
}

pub trait RW<T> {
    fn read_lock(&self) -> RwLockReadGuard<T>;
    fn write_lock(&self) -> RwLockWriteGuard<T>;
}

impl<T> RW<T> for RwLock<T> {
    fn read_lock(&self) -> RwLockReadGuard<T> {
        self.read()
            .unwrap_or_else(|poisoned| poisoned.into_inner())
    }
    fn write_lock(&self) -> RwLockWriteGuard<T> {
        self.write()
            .unwrap_or_else(|poisoned| poisoned.into_inner())
    }
}

lazy_static! {
    pub static ref CONFIG: RwLock<Config> = {
        let m:Config = Default::default();
        RwLock::new(m)
    };
}
```

`RW` trait 增加了 mutex poisoning 时的处理。

使用

```rust
use xxx::{CONFIG, RW};

let access_token = CONFIG
            .read_lock()
            .access_token
            .clone()
            .unwrap_or("".to_owned());  // access 是一个Option 对象，因而需要进行如此的处理
```

# reference

+ [rustwebapp](https://github.com/superlogical/rustwebapp)
+ [web docker](https://github.com/clementmiao/website-rocket)
+ [thanks](https://github.com/rust-lang-nursery/thanks)
+ [rustironreact](https://github.com/cmsd2/rust-iron-react-webpack)

