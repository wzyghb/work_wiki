
## Overview

### why rust
+ Fast (naive code, no garbage collector, most abstractions has zero cost, fine-grained control over lots of things)
+ Safe (no null, no uninitialized memory, no dangling pointers, no double free errors, no manual memory management)
+ Functional (First-class functions, Trait-based generics, Algebraic datatypes, Pattern matching)

### Tools

#### Rustc

#### Cargo

+ `cargo new project_name`
+ `cargo new project_name --bin`
+ `cargo build`
+ `cargo test`

##### `Cargo.toml`

```
[package]
name = "rust"
version = "0.1.0"
authors = ["ddd@xxx.com"]

[dependencies]
uuid = "0.1"
rand = "0.3"

[profile.release]
opt-level = 3
debug = false

```

####

### Basic rust syntax

#### Variable Bindings

```rust
let x = 17;
let x: i16 = 17;
let mut y = 5;
y += 1;
let (a, b) = ("foo", 12);
```

#### Expressions

+ Everything is an expression: something which returns a value.
+ `nothing` type is called `unit`, which is written `()`
+ A expression appending a semicolon return `()`.

```rust
let y = if x > 0 { "greeter" } else { "less" }
```
 
 #### Comments

 ```rust
 /// docstring comments
 /// 
 /// `rustdoc` use docstring comments to generate documentatiion, support **Markdown** formatting.
 ///
 fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
 ```

#### Types

##### Primitive Types

+ bool
+ char 'c' '狗' is Unicodel
+ Numerics:
    - i8, i16, i32, i64, isize
    - u8, u16, u32, u64, usize
    - f32, f64
    - isize and usize are the size of pointers, have machine dependencies
    - Literial splled 10i8, 10u16 10.0f32, 10usize
+ Arrays, slices, str, tuples
    - Array: [T; N] cannot be resize, access will be bounds-checked at runtime
    - Slices: &[T] a "view" into an array by reference, created directly, borrowed from other variables
    - Strings: String, &str
    - Tuples: fixed size, ordered, heterogeneous list, let bindings desctructure
+ Vec<T>
```rust
let init_arr = [2; 32];
let arr = [1, 2, 3, 4, 5];
let total_slice = &arr;
let total_slice = &arr[..];
let partial_slice = &arr[2..5];

let s: &str = "hello";
let s2: String = "hello".to_string();
let s3: String = String::from("hello");
let s4: &str = &s3

let x: i32 = 100;
let y: u32 = x as u32;
```

#### Functions

```rust
fn square_bad(n: i32) -> i32 {
    n * n
}

let x: fn(i32) -> i32 = square_bad;
fn apply_twice(f: &Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

apply_twice(&square_bad, 3);
```

#### Marcros!
+ `print!`, `println!`
+ `format!`
+ `panic!`
+ `assert!`, `assert_eq!`
+ `unreachable!`
+ `unimplemented!`

#### Match Statements

+ `...` specify a range of values
+ `_` bind against any value
+ `if-let`
+ `while-let`
+ inner bindings

```rust
let x = 3;
let y = -3;

match (x, y) {
    (1, 1) => println!("one"),
    (2, j) => println!("two, {}", j),
    (_, 3) => println!("three"),
    (i, j) if i > 5 && j < 0 => println!("On guard!"),
    (_, _) => println!(":<"),
}

let x = 17;

match x {
    0 ... 5 => println!("zero through five (inclusive)"),
    _ => println!("You still lose the game."),
}

let result = make_request();

if let Resultish::Err(s) = result {
    println!("Total and utter failure: {}", s);
} else {
    println!("ok.");
}

while let Resultish::Err(s) = make_request() {
    println!("Total and utter failure: {}", s);
}

#[derive(Debug)]
enum A { None, Some(B) }
#[derive(Debug)]
enum B { None, Some(i32) }

fn foo(x: A) {
    match x {
        a @ A::None              => println!("a is A::{:?}", a),
        ref a @ A::Some(B::None) => println!("a is A::{:?}", *a),
        A::Some(b @ B::Some(_))  => println!("b is B::{:?}", b),
    }
}

foo(A::None);             // ==> x is A::None
foo(A::Some(B::None));    // ==> a is A::Some(None)
foo(A::Some(B::Some(5))); // ==> b is B::Some(5)
```

## Ownership, Borrowing, Lifetimes

> 以后再总结

+ Ownership checked at compile time, no running time costs
+ A piece of data can only hava one owner at a time
+ when bingding goes out of scope,bound data is released automatically
+ move semantics
+ Multiple Lifetime Parameters
+ `'static` a reference may be kept for the lifetime of the entire program, never go out of scope, `'str` is `'static`

```rust
struct Pizza(Vec<i32>);
struct PizzaSlice<'a> { pizza: &'a Pizza, index: u32 }
struct PizzaConsumer<'a, 'b: 'a> { // says "b outlives a"
    slice: PizzaSlice<'a>, // <- currently eating this one
    pizza: &'b Pizza,      // <- so we can get more pizza
}

fn get_another_slice(c: &mut PizzaConsumer, index: u32) {
    c.slice = PizzaSlice { pizza: c.pizza, index: index };
}

let p = Pizza(vec![1, 2, 3, 4]);
{
    let s = PizzaSlice { pizza: &p, index: 1 };
    let mut c = PizzaConsumer { slice: s, pizza: &p };
    get_another_slice(&mut c, 2);
}
```

## Data Struct

### Struct
+ struct may not be partially-initialized
+ do not have field-level mutability
+ stucts fields are private by default - can only be accessed from within module where the struct is declared
+ tuple structs

```rust
pub struct Point {
    x: i32,
    y: i32,
}

match p {
    Point { x, y } => println!("({}, {})", x, y)
}

match p {
    Point { y, .. } => println!("{}", y)
}

struct Foo { a: i32, b: i32, c: i32, d: i32, e: i32 }

let mut x = Foo { a: 1, b: 1, c: 2, d: 2, e: 3 };
let x2 = Foo { e: 4, .. x };

// Useful to update multiple fields of the same struct:
x = Foo { a: 2, b: 2, e: 2, .. x };

struct Color(i32, i32, i32);

let mut c = Color(0, 255, 255);
c.0 = 255;
match c {
    Color(r, g, b) => println!("({}, {}, {})", r, g, b)
}
// Not equatable
struct Meters(i32);
struct Yards(i32);

// May be compared using `==`, added with `+`, etc.
type MetersAlias = i32;
type YardsAlias  = i32;

struct Unit;
let u = Unit;
```

### Enums

+ No data
+ Named data
+ Unnamed ordered data

```rust
enum Resultish {
    Ok,
    Warning { code: i32, message: String },
    Err(String)
}

match make_request() {
    Resultish::Ok =>
        println!("Success!"),
    Resultish::Warning { code, message } =>
        println!("Warning: {}!", message),
    Resultish::Err(s) =>
        println!("Failed with error: {}", s),
}
```

### Method

+ `&self`, `&mut self`, `self`

```rust
impl Point {
    fn distance(&self, other: Point) -> f32 {
        let (dx, dy) = (self.x - other.x, self.y - other.y);
        ((dx.pow(2) + dy.pow(2)) as f32).sqrt()
    }

    fn translate(&mut self, x: i32, y: i32) {
        self.x += x;
        self.y += y;
    }

    fn mirror_y(self) -> Point {
        Point { x: -self.x, y: self.y }
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.distance();
}

```

### Associated Functions

```rust
impl Point {
    fn new(x: i32, y: i32) -> Point {
        Point { x: x, y: y }
    }
}

fn main() {
    let p = Point::new(1, 2);
}
```


### Recursive Types

#### Boxes

+ box: a general term for one of Rust's ways of allocating data on the heap
+ Box<T> is a heap pointer with exactly one owner
+ when go out of scope, Box will automatically destructed

```
let boxed_five = Box::new(5);

enum List {
    Nil,
    Cons(i32, Box(List)),
}
```

## Generics

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

struct Point<T> {
    x: T,
    y: T,
}

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>),
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        match *self {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

```

### Generic Functions

```rust
fn foo<T, U>(x: T, y: U) {
    // ...
}
```

### Generics with Triat Bounds

```rust
fn cloning_machine<T: Clone>(t: T) -> (T, T) {
    (t.clone(), t.clone())
}

fn cloning_machine_2<T>(t: T) -> (T, T)
        where T: Clone {
    (t.clone(), t.clone())
}

fn clone_and_compare<T: Clone + Ord>(t1: T, t2: T) -> bool {
   t1.clone() > t2.clone()
}

enum Result<T, E> {
   Ok(T),
   Err(E),
}

trait PrettyPrint {
   fn format(&self) -> String;
}

impl<T: PrettyPrint, E: PrettyPrint> PrettyPrint for Result<T, E> {
   fn format(&self) -> String {
      match *self {
         Ok(t) => format!("Ok({})", t.format()),
         Err(e) => format!("Err({})", e.format()),
      }
   }
}
```

## Traits

```rust

trait PrettyPrint {
    fn format(&self) -> String;
}

struct Point {
    x: i32,
    y: i32,
}

impl PrettyPrint for Point {
    fn format(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}
```

### Trait Inheritance

+ `Eq` requires `PartialEq`, `Copy` requires `Clone`
+ Implementing the `Child` trait also requires you implement `Parent`

```rust
trait Parent {
    fn foo(&self) {
        // ...
    }
}

trait Child: Parent {
    fn bar(&self) {
        self.foo();
        // ...
    }
}
```

### Default Methods

+ trait can have default implementations for methods

```rust
trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)
    }
}

trait Eq: PartialEq<Self> {}
```

### Deriving

+ A `#[derive(...)]` attribute tells the compiler to insert a default implementation for whatever traits you tell it to

```rust
#[derive(Eq, PartialEq, Debug)]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

#### Clone

+ how to duplicate a value of type T
+ can solve ownership problems

```rust
pub trait Clone: Sized {
    fn clone(&self) -> Self;
    fn clone_from(&mut self, source: &Self) { ... }
}

// use:

#[derive(Clone)] // without this, Bar cannot derive Clone.
struct Foo {
    x: i32,
}

#[derive(Clone)]
struct Bar {
    x: Foo,
}
```

#### Copy

+ Copy denotes that a type has "copy semantics" instead of "move semantics."
+ Type must be able to copied by copying bits, Types that contain references cannot be copy

```rust
pub trait Copy: Clone { }
```

#### Debug

+ defines output for the `{:?}` formatting option

```rust
pub trait Debug {
    fn fmt(&self, &mut Formatter) -> Result;
}
```

#### Default

```rust
pub trait Default: Sized {
    fn default() -> Self;
}
```

#### Eq vs. PartialEq

```rust
pub trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool { ... }
}

pub trait Eq: PartialEq<Self> {}
```

| name | condition |
|:--- |:--- |
| PartialEq | Symmetric, Transitive |
| Eq | Symmetric, Transitive, Reflexive |

+ Symmetrics: `a == b` => `b == a`
+ Transitive: `a == b` and `b == c` => `a == c`
+ Reflexive:  `a == a`

#### Hash

```rust
pub trait Hash {
    fn hash<H: Hasher>(&self, state: &mut H);
    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)
        where Self: Sized { ... }
}
```

+ a hashable type
+ H type parameter is an abstract hash state for computing the hash
+ `Eq` and `Hash` trait should have constraint: `k1 == k2` => `hash(k1) == hash(k2)`

#### Ord vs. PartialOrd

```rust
pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {
    // Ordering is one of Less, Equal, Greater
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd<Self> {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

#### Associated Types

##### Primative solution

+ `N` and `E` don't have any meaningful association to graph
+ method `distance`  shoudl also be generic over `N` and `E`

```rust
trait Graph<N, E> {
    fn edges(&self, &N) -> Vec<E>;
    // etc
}

fn distance<N, E, G: Graph<N,E>>(graph: &G, start: &N, end: &N)
    -> u32 { /*...*/ }
```

##### Associated Types solution

```rust
trait Graph {
  type N;
  type E;

  fn edges(&self, &Self::N) -> Vec<Self::E>;
}

impl Graph for MyGraph {
  type N = MyNode;
  type E = MyEdge;

  fn edges(&self, n: &MyNode) -> Vec<MyEdge> { /*...*/ }
}
```

#### Trait Scope

+ It's possible to implement this trait on any type in rust, including types that you don't own.
+ You need to use a trait in order to access its methods on types, even if you have access to the type.
+ In order to write an impl, you need to own (i.e. have yourself defined) either the trait or the type.

#### Display

+ defind output for {} formatting option

```rust
pub trait Display {
    fn fmt(&self, &mut Formatter) -> Result<(), Error>;
}

impl Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point {}, {})", self.x, self.y)
    }
}
```

#### Addendum: Drop

+ a trait for destructable
+ never call this method yourself
+ 

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

## Closure

### Basic Syntax

```rust
let foo_v1 = |x: i32| { x * x };
let foo_v2 = |x: i32, y: i32| x * y;
let foo_v3 = |x: i32| {
    // Very Important Arithmetic
    let y = x * 2;
    let z = 4 + y;
    x + y + z
};
let foo_v4 = |x: i32| if x == 0 { 0 } else { 1 };
```

### Closure Environment

> 待总结

### Closure Traits

```rust
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call"
      fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call"
      fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    type Output;

    extern "rust-call"
      fn call_once(self, args: Args) -> Self::Output;
}
```

### Closure as Arguments

```rust
// self = Vec<A>
fn map<A, B, F>(self, f: F) -> Vec<B>
    where F: FnMut(A) -> B;
```

### Closure as Return values

```rust
// error!
fn i_need_some_closure() -> (Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// reviewed but error
fn i_need_some_closure_by_reference() -> &(Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// final
fn box_up_your_closure_and_move_out() -> Box<Fn(i32) -> i32> {
    let local = 2;
    Box::new(move |x| x * local)
}
```

## Std Lib

### String

+ A String and an &str may be concatenated with +, Concatenating two Strings requires coercing one to &str.

concersion case:

```rust
use std::net::TcpStream;

TcpStream::connect("192.168.0.1:3000"); // &str
let addr = "192.168.0.1:3000".to_string();
TcpStream::connect(&*addr);
```
This doesn't automatically coerce because TcpStream doesn't take an argument of type &str, but a Trait bounded type:
`TcpStream::connect<A: ToSocketAddr>(addr: A)`

```rust
trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

+ Since String implements Deref<Target=str>, so values of &String will automatically be dereferenced to &str when possible.
