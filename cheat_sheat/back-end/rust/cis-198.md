
## Overview

### why rust
+ Fast (naive code, no garbage collector, most abstractions has zero cost, fine-grained control over lots of things)
+ Safe (no null, no uninitialized memory, no dangling pointers, no double free errors, no manual memory management)
+ Functional (First-class functions, Trait-based generics, Algebraic datatypes, Pattern matching)

### Tools

#### Rustc

#### Cargo

+ `cargo new project_name`
+ `cargo new project_name --bin`
+ `cargo build`
+ `cargo test`

##### `Cargo.toml`

```
[package]
name = "rust"
version = "0.1.0"
authors = ["ddd@xxx.com"]

[dependencies]
uuid = "0.1"
rand = "0.3"

[profile.release]
opt-level = 3
debug = false

```

####

### Basic rust syntax

#### Variable Bindings

```rust
let x = 17;
let x: i16 = 17;
let mut y = 5;
y += 1;
let (a, b) = ("foo", 12);
```

#### Expressions

+ Everything is an expression: something which returns a value.
+ `nothing` type is called `unit`, which is written `()`
+ A expression appending a semicolon return `()`.

```rust
let y = if x > 0 { "greeter" } else { "less" }
```
 
 #### Comments

 ```rust
 /// docstring comments
 /// 
 /// `rustdoc` use docstring comments to generate documentatiion, support **Markdown** formatting.
 ///
 fn foo() {
    // Double-slash comments are normal.

    /* Block comments
     * also exist /* and can be nested! */
     */
}
 ```

#### Types

##### Primitive Types

+ bool
+ char 'c' '狗' is Unicodel
+ Numerics:
    - i8, i16, i32, i64, isize
    - u8, u16, u32, u64, usize
    - f32, f64
    - isize and usize are the size of pointers, have machine dependencies
    - Literial splled 10i8, 10u16 10.0f32, 10usize
+ Arrays, slices, str, tuples
    - Array: [T; N] cannot be resize, access will be bounds-checked at runtime
    - Slices: &[T] a "view" into an array by reference, created directly, borrowed from other variables
    - Strings: String, &str
    - Tuples: fixed size, ordered, heterogeneous list, let bindings desctructure
+ Vec<T>
```rust
let init_arr = [2; 32];
let arr = [1, 2, 3, 4, 5];
let total_slice = &arr;
let total_slice = &arr[..];
let partial_slice = &arr[2..5];

let s: &str = "hello";
let s2: String = "hello".to_string();
let s3: String = String::from("hello");
let s4: &str = &s3

let x: i32 = 100;
let y: u32 = x as u32;
```

#### Functions

```rust
fn square_bad(n: i32) -> i32 {
    n * n
}

let x: fn(i32) -> i32 = square_bad;
fn apply_twice(f: &Fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

apply_twice(&square_bad, 3);
```

#### Marcros!
+ `print!`, `println!`
+ `format!`
+ `panic!`
+ `assert!`, `assert_eq!`
+ `unreachable!`
+ `unimplemented!`

#### Match Statements

+ `...` specify a range of values
+ `_` bind against any value
+ `if-let`
+ `while-let`
+ inner bindings

```rust
let x = 3;
let y = -3;

match (x, y) {
    (1, 1) => println!("one"),
    (2, j) => println!("two, {}", j),
    (_, 3) => println!("three"),
    (i, j) if i > 5 && j < 0 => println!("On guard!"),
    (_, _) => println!(":<"),
}

let x = 17;

match x {
    0 ... 5 => println!("zero through five (inclusive)"),
    _ => println!("You still lose the game."),
}

let result = make_request();

if let Resultish::Err(s) = result {
    println!("Total and utter failure: {}", s);
} else {
    println!("ok.");
}

while let Resultish::Err(s) = make_request() {
    println!("Total and utter failure: {}", s);
}

#[derive(Debug)]
enum A { None, Some(B) }
#[derive(Debug)]
enum B { None, Some(i32) }

fn foo(x: A) {
    match x {
        a @ A::None              => println!("a is A::{:?}", a),
        ref a @ A::Some(B::None) => println!("a is A::{:?}", *a),
        A::Some(b @ B::Some(_))  => println!("b is B::{:?}", b),
    }
}

foo(A::None);             // ==> x is A::None
foo(A::Some(B::None));    // ==> a is A::Some(None)
foo(A::Some(B::Some(5))); // ==> b is B::Some(5)
```

## Ownership, Borrowing, Lifetimes

> 以后再总结

+ Ownership checked at compile time, no running time costs
+ A piece of data can only hava one owner at a time
+ when bingding goes out of scope,bound data is released automatically
+ move semantics
+ Multiple Lifetime Parameters
+ `'static` a reference may be kept for the lifetime of the entire program, never go out of scope, `'str` is `'static`

```rust
struct Pizza(Vec<i32>);
struct PizzaSlice<'a> { pizza: &'a Pizza, index: u32 }
struct PizzaConsumer<'a, 'b: 'a> { // says "b outlives a"
    slice: PizzaSlice<'a>, // <- currently eating this one
    pizza: &'b Pizza,      // <- so we can get more pizza
}

fn get_another_slice(c: &mut PizzaConsumer, index: u32) {
    c.slice = PizzaSlice { pizza: c.pizza, index: index };
}

let p = Pizza(vec![1, 2, 3, 4]);
{
    let s = PizzaSlice { pizza: &p, index: 1 };
    let mut c = PizzaConsumer { slice: s, pizza: &p };
    get_another_slice(&mut c, 2);
}
```

1. 定义在 struct、返回值、enum、Type 中的引用类型必须规定好 Lifetime 参数。函数中有 lifetime elision 但有可能不够。
2. 维持一个内存对象的指针和引用是危险的，主要来自于以下两个方面：
    1. 指针指向的一个已经离开可见范围的对象。
    2. 指针指向一个已经修改到别处的对象。

可以将 Lifetime 认为是程序中一个可见范围的名称，当一个 reference 存在一个 lifetime 时，我们认为他在这整个范围内是合法的。
不同情况下，reference 有不同的必须或可以合法的范围。整个 lifetime 系统从另一方面讲，知识一种限定解决系统，管理每个 refenece 的可见范围。当发现 lifetime 的集合满足所有的限制时，你的程序便可以编译，否则，你会快速给你错误信息。

在函数内部，编译器可以获得足够的信息来处理所有的 lifetime，但是对于整个 type 和 API 层，编译器则无法获得全部的信息，需要你来告诉他一些信息。

指针错误是全局的，难以发现和处理。rust 使用 lifetime，使得我们可以在函数内部发现和处理这些问题。rust 可以保证，没有对象会在 free 后还被使用，以及还有外部指针指向它时，被修改。


## Data Struct

### Struct
+ struct may not be partially-initialized
+ do not have field-level mutability
+ stucts fields are private by default - can only be accessed from within module where the struct is declared
+ tuple structs

```rust
pub struct Point {
    x: i32,
    y: i32,
}

match p {
    Point { x, y } => println!("({}, {})", x, y)
}

match p {
    Point { y, .. } => println!("{}", y)
}

struct Foo { a: i32, b: i32, c: i32, d: i32, e: i32 }

let mut x = Foo { a: 1, b: 1, c: 2, d: 2, e: 3 };
let x2 = Foo { e: 4, .. x };

// Useful to update multiple fields of the same struct:
x = Foo { a: 2, b: 2, e: 2, .. x };

struct Color(i32, i32, i32);

let mut c = Color(0, 255, 255);
c.0 = 255;
match c {
    Color(r, g, b) => println!("({}, {}, {})", r, g, b)
}
// Not equatable
struct Meters(i32);
struct Yards(i32);

// May be compared using `==`, added with `+`, etc.
type MetersAlias = i32;
type YardsAlias  = i32;

struct Unit;
let u = Unit;
```

### Enums

+ No data
+ Named data
+ Unnamed ordered data

```rust
enum Resultish {
    Ok,
    Warning { code: i32, message: String },
    Err(String)
}

match make_request() {
    Resultish::Ok =>
        println!("Success!"),
    Resultish::Warning { code, message } =>
        println!("Warning: {}!", message),
    Resultish::Err(s) =>
        println!("Failed with error: {}", s),
}
```

### Method

+ `&self`, `&mut self`, `self`

```rust
impl Point {
    fn distance(&self, other: Point) -> f32 {
        let (dx, dy) = (self.x - other.x, self.y - other.y);
        ((dx.pow(2) + dy.pow(2)) as f32).sqrt()
    }

    fn translate(&mut self, x: i32, y: i32) {
        self.x += x;
        self.y += y;
    }

    fn mirror_y(self) -> Point {
        Point { x: -self.x, y: self.y }
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.distance();
}

```

### Associated Functions

```rust
impl Point {
    fn new(x: i32, y: i32) -> Point {
        Point { x: x, y: y }
    }
}

fn main() {
    let p = Point::new(1, 2);
}
```


### Recursive Types

#### Boxes

+ box: a general term for one of Rust's ways of allocating data on the heap
+ Box<T> is a heap pointer with exactly one owner
+ when go out of scope, Box will automatically destructed

```
let boxed_five = Box::new(5);

enum List {
    Nil,
    Cons(i32, Box(List)),
}
```

## Generics

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

struct Point<T> {
    x: T,
    y: T,
}

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>),
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        match *self {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

```

### Generic Functions

```rust
fn foo<T, U>(x: T, y: U) {
    // ...
}
```

### Generics with Triat Bounds

```rust
fn cloning_machine<T: Clone>(t: T) -> (T, T) {
    (t.clone(), t.clone())
}

fn cloning_machine_2<T>(t: T) -> (T, T)
        where T: Clone {
    (t.clone(), t.clone())
}

fn clone_and_compare<T: Clone + Ord>(t1: T, t2: T) -> bool {
   t1.clone() > t2.clone()
}

enum Result<T, E> {
   Ok(T),
   Err(E),
}

trait PrettyPrint {
   fn format(&self) -> String;
}

impl<T: PrettyPrint, E: PrettyPrint> PrettyPrint for Result<T, E> {
   fn format(&self) -> String {
      match *self {
         Ok(t) => format!("Ok({})", t.format()),
         Err(e) => format!("Err({})", e.format()),
      }
   }
}
```

## Traits

```rust

trait PrettyPrint {
    fn format(&self) -> String;
}

struct Point {
    x: i32,
    y: i32,
}

impl PrettyPrint for Point {
    fn format(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}
```

### Trait Inheritance

+ `Eq` requires `PartialEq`, `Copy` requires `Clone`
+ Implementing the `Child` trait also requires you implement `Parent`

```rust
trait Parent {
    fn foo(&self) {
        // ...
    }
}

trait Child: Parent {
    fn bar(&self) {
        self.foo();
        // ...
    }
}
```

### Default Methods

+ trait can have default implementations for methods

```rust
trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool {
        !self.eq(other)
    }
}

trait Eq: PartialEq<Self> {}
```

### Deriving

+ A `#[derive(...)]` attribute tells the compiler to insert a default implementation for whatever traits you tell it to

```rust
#[derive(Eq, PartialEq, Debug)]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

#### Clone

+ how to duplicate a value of type T
+ can solve ownership problems

```rust
pub trait Clone: Sized {
    fn clone(&self) -> Self;
    fn clone_from(&mut self, source: &Self) { ... }
}

// use:

#[derive(Clone)] // without this, Bar cannot derive Clone.
struct Foo {
    x: i32,
}

#[derive(Clone)]
struct Bar {
    x: Foo,
}
```

#### Copy

+ Copy denotes that a type has "copy semantics" instead of "move semantics."
+ Type must be able to copied by copying bits, Types that contain references cannot be copy

```rust
pub trait Copy: Clone { }
```

#### Debug

+ defines output for the `{:?}` formatting option

```rust
pub trait Debug {
    fn fmt(&self, &mut Formatter) -> Result;
}
```

#### Default

```rust
pub trait Default: Sized {
    fn default() -> Self;
}
```

#### Eq vs. PartialEq

```rust
pub trait PartialEq<Rhs: ?Sized = Self> {
    fn eq(&self, other: &Rhs) -> bool;

    fn ne(&self, other: &Rhs) -> bool { ... }
}

pub trait Eq: PartialEq<Self> {}
```

| name | condition |
|:--- |:--- |
| PartialEq | Symmetric, Transitive |
| Eq | Symmetric, Transitive, Reflexive |

+ Symmetrics: `a == b` => `b == a`
+ Transitive: `a == b` and `b == c` => `a == c`
+ Reflexive:  `a == a`

#### Hash

```rust
pub trait Hash {
    fn hash<H: Hasher>(&self, state: &mut H);
    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)
        where Self: Sized { ... }
}
```

+ a hashable type
+ H type parameter is an abstract hash state for computing the hash
+ `Eq` and `Hash` trait should have constraint: `k1 == k2` => `hash(k1) == hash(k2)`

#### Ord vs. PartialOrd

```rust
pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {
    // Ordering is one of Less, Equal, Greater
    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

    fn lt(&self, other: &Rhs) -> bool { ... }
    fn le(&self, other: &Rhs) -> bool { ... }
    fn gt(&self, other: &Rhs) -> bool { ... }
    fn ge(&self, other: &Rhs) -> bool { ... }
}

pub trait Ord: Eq + PartialOrd<Self> {
    fn cmp(&self, other: &Self) -> Ordering;
}
```

#### Associated Types

##### Primative solution

+ `N` and `E` don't have any meaningful association to graph
+ method `distance`  shoudl also be generic over `N` and `E`

```rust
trait Graph<N, E> {
    fn edges(&self, &N) -> Vec<E>;
    // etc
}

fn distance<N, E, G: Graph<N,E>>(graph: &G, start: &N, end: &N)
    -> u32 { /*...*/ }
```

##### Associated Types solution

```rust
trait Graph {
  type N;
  type E;

  fn edges(&self, &Self::N) -> Vec<Self::E>;
}

impl Graph for MyGraph {
  type N = MyNode;
  type E = MyEdge;

  fn edges(&self, n: &MyNode) -> Vec<MyEdge> { /*...*/ }
}
```

#### Trait Scope

+ It's possible to implement this trait on any type in rust, including types that you don't own.
+ You need to use a trait in order to access its methods on types, even if you have access to the type.
+ In order to write an impl, you need to own (i.e. have yourself defined) either the trait or the type.

#### Display

+ defind output for {} formatting option

```rust
pub trait Display {
    fn fmt(&self, &mut Formatter) -> Result<(), Error>;
}

impl Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point {}, {})", self.x, self.y)
    }
}
```

#### Addendum: Drop

+ a trait for destructable
+ never call this method yourself
+ 

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

## Closure

### Basic Syntax

```rust
let foo_v1 = |x: i32| { x * x };
let foo_v2 = |x: i32, y: i32| x * y;
let foo_v3 = |x: i32| {
    // Very Important Arithmetic
    let y = x * 2;
    let z = 4 + y;
    x + y + z
};
let foo_v4 = |x: i32| if x == 0 { 0 } else { 1 };
```

### Closure Environment

> 待总结

### Closure Traits

```rust
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call"
      fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call"
      fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    type Output;

    extern "rust-call"
      fn call_once(self, args: Args) -> Self::Output;
}
```

### Closure as Arguments

```rust
// self = Vec<A>
fn map<A, B, F>(self, f: F) -> Vec<B>
    where F: FnMut(A) -> B;
```

### Closure as Return values

```rust
// error!
fn i_need_some_closure() -> (Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// reviewed but error
fn i_need_some_closure_by_reference() -> &(Fn(i32) -> i32) {
    let local = 2;
    |x| x * local
}

// final
fn box_up_your_closure_and_move_out() -> Box<Fn(i32) -> i32> {
    let local = 2;
    Box::new(move |x| x * local)
}
```

## Std Lib

### String

+ A String and an &str may be concatenated with +, Concatenating two Strings requires coercing one to &str.

concersion case:

```rust
use std::net::TcpStream;

TcpStream::connect("192.168.0.1:3000"); // &str
let addr = "192.168.0.1:3000".to_string();
TcpStream::connect(&*addr);
```
This doesn't automatically coerce because TcpStream doesn't take an argument of type &str, but a Trait bounded type:
`TcpStream::connect<A: ToSocketAddr>(addr: A)`

```rust
trait Deref {
    type Target: ?Sized;
    fn deref(&self) -> &Self::Target;
}
```

+ Since String implements `Deref<Target=str>`, so values of &String will automatically be dereferenced to &str when possible.
+ `Vec`、`&str` 可以方便的转换为 String
+  Copy a `String` is expensive;

### `Option<T>`

```rust
enum Option<T> {
    None,
    Some(T),
}

fn unwrap<T>(&self) -> T;
fn map<U, F>(self, f: F) -> Option<U> { ... };
fn and_then<U, F>(self, f: F) -> Option<U>
      where F: FnOnce(T) -> Option<U> { ... };
fn unwrap_or<T>(&self, default: T) -> T { ... };
fn unwrap_or_else<T>(&self, f: F) -> T
            where F: FnOnce() -> T { ... };

fn is_some(&self) -> bool { ... };
fn is_none(&self) -> bool { ... };
fn map_or<U, F>(self, default: U, f: F) -> U
    where F: FnOnce(T) -> U { ... };
fn map_or_else<U, D, F>(self, default: D, f: F) -> U
    where D: FnOnce() -> U, F: FnOnce(T) -> U { ... };
fn ok_or(self, err: E) -> Result<T, E> { ... };
fn ok_or_else(self, default: F) -> Result<T, E>
    where F: FnOnce() -> E { ... };
fn and<U>(self, optb: Option<U>) -> Option<U> { ... };
fn or(self, optb: Option<T>) -> Option<T> { ... };
```

### `Result<T, E>`

```rust
enum Result<T, E> {
    Ok(T),
    Err(E)
}
```

+ Unlike Option, you should always consume `Result`, such as `unwrap` or `expect` or handle `Ok` / `Err`。

### Collections

+ `Vec<T>`
+ `VecDeque<T>`
+ `LinkedList<T>`
+ `HashMap<K, V>`
    - `K: Hash + Eq`
+ `BTreeMap<K, V>`
    - `K: Ord`
+ `BinaryHeap<T>`

#### `Iterator`

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;

    // More fields omitted
}
```

+ three types of iteration:
    - `into_iter()` yield `T`
    - `iter()` yielding `&T`
    - `iter_mut()` yielding `&mut T`

##### `collect`

```rust
fn collect<B>(self) -> B where B: FromIterator<Self::Item>
```

+ `collect()` rolls a lazy iterator back into an actual collection。
+  target collection must define the `FromIterator` trait for the `Item` inside the Iterator.
+ Sometimes needs a type hint to properly compile.

##### `fold`

```rust
fn fold<B, F>(self, init: B, f: F) -> B
    where F: FnMut(B, Self::Item) -> B;
```

##### `filter`

```rust
fn filter<P>(self, predicate: P) -> Filter<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```
+ `filter` returns a `Filter<Self, P>`

##### `find` and `position`

```rust
fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
    where P: FnMut(Self::Item) -> bool;

fn position<P>(&mut self, predicate: P) -> Option<usize>
    where P: FnMut(Self::Item) -> bool;
```

##### `skip`

```rust
fn skip(self, n: usize) -> Skip<Self>;
```

##### `zip`

```rust
fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>
    where U: IntoIterator;
```

##### `any` and `all`

```rust
fn any<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;

fn all<F>(&mut self, f: F) -> bool
    where F: FnMut(Self::Item) -> bool;
```

##### `enumerate`

+ use enumerate!
+ (index, value)

```rust
fn enumerate(self) -> Enumerate<Self>;
```

##### Iterator Adapters
+ Adapters operate on an iterator and return a new iterator
+ offen lazy
+ use iterator consumer on an adapter or use it in a for loop

##### `map`

```rust
fn map<B, F>(self, f: F) -> Map<Self, F>
    where F: FnMut(Self::Item) -> B;
```

##### `take` and `take_while`

```rust
fn take(self, n: usize) -> Take<Self>;

fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>
    where P: FnMut(&Self::Item) -> bool;
```

##### `cloned`

```rust
fn cloned<'a, T>(self) -> Cloned<Self>
    where T: 'a + Clone, Self: Iterator<Item=&'a T>;
```

+ Create an iteratir which calls clone on all of its elements.
+ equal to `vs.iter().map(|v| v.clone())`
+ Using: when you have an iterator over `&T`, but need one over `T`

## Pointer Types

+ `&T` and `&mut T`
+ `Box<T>`
+ `std:rc::Rc<T>` `Rc::downgrade()`
+ `std::rc::Weak<T>` `weak.upgrade() -> Option<Rc<T>>`
+ `Cell<T>` 
    - Just providing interior mutability of `Copy` types.
    - With `get()` and `set()` never mutate `T`, just replace it.    
+ `RefCell<T>` 
    - Dynamic borrow checking rules, maybe panic at runtime.
    - `borrow()` and `borrow_mut()`
    - not thread safe, maybe panic at runtime.
    - A common paradigm is putting a `RefCell` inside an `Rc` allow shared mutability
+ `std::cell::Ref<T>` and `RefMut<T>`
    - when you invoke `borrow()` on a `RefCell<T>` actually get `Ref<T>` not `&T`
    - while `borrow_mut()` gives you a `RefMut<T>`
+ `*const T` and `*mut T`
    - no ownership, no lifetime, C-like raw pointers
    - require `unsafe` before dereference

```rust
let c = Cell::new(10);
c.set(2);
println!("{}", c.get());
```

## Misc Syntax

+ `const` must annotate type, and is `live` for the duration of the program, may hava multi references.
+ `static` must annotate type, with fixed memory address, unsafe to mutate, with `static` lifetime.

```rust
const PI: f32 = 3.14159;
static PI: f32 = 3.14159;
```

## Modules and Crates

+ Everything in rust is module-scoped: if it's not pub, it's only accessible from within the same module.

### 1. Modules can be defined within one file

```rust
mod english {
    pub mod greetings {
    }
    pub mod farewells {
    }
}

mod japanese {
    pub mod greetings {
    }
    pub mod farewells {
    }
}
```

### 2. Modules can be defined as files instead

+ `lib.rs`
```rust
mod english;
```
+ `english.rs`
```rust
pub mod greetings { /* .... */ }
```

### 3. Modules can be defined as directories

+ `lib.rs`
```rust
mod english;
```

+ `english/`
    - `mod.rs`
        ```rust
        pub mod greetings;
        ```
    - `greetings.rs`
        ```rust
        /* .... */
        ```

### 4 Namespacing

```rust
mod one {
    mod two {
        fn foo() { ... }
    }
    fn bar() {
        two::foo();
    }
}

mod three {
    mod four {
        pub fn foo() { ... }
    }

    fn bar() {
        ::one::two::foo();
    }
}
```

### 5 `use` in Modules
+ `use` directives are absolute by default
+ can be relative to the current module
+ `pub use` can be used to re-export other items

```rust
use english::greetings;
use self::greetings;
use super::japanese;

#[cfg(english)]
pub use english::*;

#[cfg(japanese)]
pub use japanese::*;
```

## Crate

```rust
extern crate rand;

use rand::Rng;
```

```yaml
[dependencies]
myfoo = { git = "https://github.com/me/foo-rs" }
mybar = { path = "../rust-bar" }

// or
[dependencies]
git = "https://github.com/me/foo-rs"
```

## Cargo

+ cargo allows both: `/src/lib.rs/` and `/src/main.rs`
+ cargo will also build: `/src/bin/*.rs` as executables.
+ Examples in `/examples/*.rs` will build by `cargo test`, can be called with `cargo run --example foo`
+ integrate tests in: `/tests/*.rs`
+ benchmarks in `/benches/*.rs`


### Features

+ build time use: `cargo build --features using-html9`

```yaml
[package]
name = "myfacebumblr"

[features]
# Enable default dependencies: require web-vortal *feature*
default = ["web-vortal"]

# Extra feature; now we can use #[cfg(feature = "web-vortal")]
web-vortal = []

# Also require h9rbs-js *crate* with its commodore64 feature.
using-html9 = ["h9rbs-js/commodore64"]

[dependencies]
# Optional dependency can be enabled by either:
# (a) feature dependencies or (b) extern crate h9rbs_js.
h9rbs-js = { optional = "true" }
```

### build scripts

script write by rust can provide more cargo can do.

```rust
[package]
build = "build.rs"
```

### Attributes

+ `#[test]`
+ `#![test]`
+ `#![no_std]`
+ `#[inline(always)]`
+ `#[allow(missing_docs)]`
+ `#![crate_type = "lib"]`
+ `#![feature(box_syntax)]`
+ `#[cfg(target_os = "linux")]`


## [Rust Code Stype](https://github.com/cis198-2016s/slides/blob/gh-pages/07/content.md#rust-code-style-1)

+ `CamelCase`:              types, traits.
+ `lowerCamelCase`:         not used.
+ `snake_case`:             crates, modules, functions, methods, variables.
+ `SCREAMING_SNAKE_CASE`:   static variables and constants.
+ `T`                       (single capital letter): type parameters.
+ `'a`                      (tick + short lowercase name): lifetime parameters.

+ Constructor and conversions should be worded:
    - `new`, `new_with_stuff`: constructors.
    - `from_foo`: conversion constructors.
    - `as_foo`: free non-consuming conversion.
    - `to_foo`: expensive non-consuming conversion.
    - `into_foo`: consuming conversion.

## `format!`

+ `{<num>:<triat>}`
    - `<num>` the index of the argument list
    - `<trait>` use of trait

| spec | trait |
|:---  |:--- |
| `{}` | Display |
| `{:x}` | LowerHex |
| `{:b}` | Binary |
| `{:?}` | Debug |
| `{:X}` | UpperHex |
| `{:e}` | LowerExp |
| `{:o}` | Octal |
| `{:p}` | Pointer |
| `{:E}` | UpperExp |

+ `{:04}` -> `0010`: padding
+ `'{:^4}'` -> `' 10 '`: alignment (centering)
+ `#` indicates an "alternate" print format:
+ `{:#X}` -> `0xA`: including 0x
+ `{:#?}`: Pretty-prints objects

## Operators

+ Unary operators: `!` `-` `*` `&` `&mut`
+ `as` casting
+ `*` `/` `%` multiplicative arithmetic
+ `+` `-` additive arithmetic
+ `<<` `>>` shift arithmetic
+ `&` bitwise and
+ `^` bitwise xor
+ `|` bitwise or
+ `==` `!=` `<` `>` `<=` `>=` logical comparison
+ `&&` logical and
+ `||` logical or
+ `=` `..` assignment and ranges

### trait for Operators:
+ Rust defines these - surprise! - using traits, in `std::ops`.
    - `Neg`, `Not`, `Deref`, `DerefMut`
    - `Mul`, `Div`, `Mod`
    - `Add`, `Sub`
    - `Shl`, `Shr`
    - `BitAnd`
    - `BitXor`
    - `BitOr`
    - `Eq`, `PartialEq`, `Ord`, `PartialOrd`
    - `And`
    - `Or`
+ Also: `Fn`, `FnMut`, `FnOnce`, `Index`, `IndexMut`, `Drop`

+ Casting (as) cannot be overloaded. we use `From` an `Into`
    - `trait From<T> { fn from(T) -> Self; }`  called: `Y::from(x)`
    - `trait Into<T> { fn into(self) -> T; }`  called: `x.into()`

```rust
struct A(Vec<i32>);

impl From<Vec<i32>> for A {
    fn from(v: Vec<i32>) -> Self {
        A(v)
    }
}

/// `From` is impossible， so only `Into` is allowed.
impl From<A> for Vec<i32> { // error: private type A in
    fn from(a: A) -> Self { // exported type signature.
        let A(v) = a; v     // (This impl is exported because
    }                       // both the trait (From) and the type
}                           // (Vec) are visible from outside.)

impl Into<Vec<i32>> for A {
    fn into(self) -> Vec<i32> {
        let A(v) = self; v
    }
}
```

### Making Reference

+ `Borrow` / `BorrowMut`: a trait for borrowing data [doc](https://doc.rust-lang.org/std/borrow/trait.Borrow.html)
```rust
trait Borrow<Borrowed> { fn borrow(&self) -> Borrowed; }
```

+ `AsRef` / `AsMut` a cheap, reference-to-reference conversion [doc](https://doc.rust-lang.org/std/convert/trait.AsRef.html)
```rust
trait AsRef<T> { fn as_ref(&self) => &T; }
```

+ If you are implementing Borrow and both Self and Borrowed implement Hash, Eq, and/or Ord, they must produce the same result.
+ Borrow has a blanket implementation: `impl<T> Borrow<T> for T`: you can always convert `T` to `&T`.
+ AsRef actually has its own blanket implementation:
    - `impl<'a, T, U> AsRef<U> for &'a T where T: AsRef<U>`
    - For all `T`, if `T` implements `AsRef`, `&T` also implements `AsRef`

## I/O

### Trait

```rust
pub trait Read {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
    // other methods implemented in terms of read
}

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    // other methods implemented in terms of write() and flash()
}
```

+ Standard IO traits implemented for a variety of types:
    - `File`, `TcpStream`, `Vec<T>`, `&[u8]`
+ return `std::io::Result` not the `std::Result`
    - `type Result<T> = Result<T, std::io::Error>`

### `std::io::Read`

```rust
use std::io;
use std::io::prelude;
use std::fs::File;

let mut f = try!(File::open("foo.txt"));
let mut buffer = [0; 10];

// read up to 10 bytes
try!(f.read(&mut buffer));
```

+ `buffer` is an array, so the max length to read is encoded into the type
+ `read` returns the number of bytes `Ok(n)` read or an Err

```rust
fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
// read to the end of the Read object
fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize>;
// reads to the end of the Read object to a string
fn read_to_string(&mut self, buf: &mut String) -> Result<usize>;
// reads exactly the length of the buffer, or throws an error
fn read_exact(&mut self, buf: &mut [u8]) -> Result<()>;
```

### Reading Iterators

```rust
fn bytes(self) -> Bytes<Self> where Self:Sized;
fn chars(self) -> Bytes<Self> where Self:Sized;
```
